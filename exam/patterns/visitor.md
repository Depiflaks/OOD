Паттерн проектирования "Посетитель"

Объясните идею паттерна Visitor своими словами: какую проблему он решает и почему она возникает именно в ООП-системах? 
    Идея заключается в отделении алгоритма от структуры данных, по которой он работает. Паттерн решает проблему «засорения» классов разнородными операциями. В ООП-системах это возникает из-за стремления инкапсулировать логику внутри классов, что делает иерархию сложной для расширения новыми функциями без модификации кода всех классов.

В примере с фигурами: почему требование “легко менять формат вывода (Plain/XML/Binary)” приводит к необходимости пересмотреть дизайн? 
    Потому что добавление методов ToXml() или ToBinary() непосредственно в классы фигур нарушает принцип единственной ответственности (SRP). Каждая фигура начинает «знать» слишком много о форматах представления, а добавление нового формата требует изменения всей иерархии классов.

Какие недостатки “классического решения” с методами вроде ToString(), ToXml(), ToBinaryArray() проявляются при росте проекта? 
    Происходит «раздувание» интерфейсов базовых классов, нарушение принципа OCP (нужно менять код при добавлении формата), усложнение поддержки и тестирования из-за размазывания логики сериализации по множеству файлов.

Как связаны Visitor и принцип Open/Closed (OCP)? В каком смысле Visitor “открывает” систему для расширения? 
    Visitor реализует OCP, позволяя добавлять новые операции над объектами (расширение поведения), не изменяя классы этих объектов. Система «открыта» для новых посетителей, но «закрыта» для изменений в классах элементов.

Опишите роли в паттерне Visitor: Visitor, ConcreteVisitor, Element, ConcreteElement, ObjectStructure. Что делает каждая роль? Ответ:

    Visitor: Объявляет методы Visit для каждого типа элемента.

    ConcreteVisitor: Реализует конкретный алгоритм (например, экспорт в XML).

    Element: Интерфейс с методом Accept(Visitor).

    ConcreteElement: Реализует Accept, вызывая соответствующий метод посетителя.

    ObjectStructure: Коллекция элементов (например, список или дерево), которую обходит посетитель.

Что именно происходит во время вызова shape.Accept(visitor) на уровне диспетчеризации методов? Почему это называют “двойной диспетчеризацией”? 
    Сначала происходит выбор метода Accept на основе типа элемента (динамическая диспетчеризация), а внутри Accept вызывается метод Visit на основе типа посетителя. В итоге выбор конкретной реализации зависит от двух типов объектов сразу, что и называется двойной диспетчеризацией.

Почему в Visitor метод Accept() обычно находится в базовом классе элементов (Shape), а методы Visit(...) — в посетителе? Какое это даёт разделение ответственности? 
    Accept — это инфраструктурный «крючок», позволяющий элементу пустить посетителя к своим данным. Методы Visit — это сама бизнес-логика. Такое разделение позволяет элементам отвечать только за данные, а посетителю — только за обработку этих данных.

В примере со слайдами StreamOutputVisitor хранит m_indent. Какие преимущества это даёт? 
    Это позволяет посетителю сохранять состояние (контекст) во время обхода дерева. Преимущество в том, что логика форматирования (отступы, вложенность) сосредоточена в одном месте, а не передается параметром через все методы отрисовки фигур.

Объясните, почему поддержка pretty-print в “классическом подходе” начинает выглядеть как “протаскивание контекста” через API. Какие проблемы это вызывает? 
    При классическом подходе вам пришлось бы добавить параметр indent в методы ToXml(int indent). Это загрязняет API бизнес-логики деталями оформления и требует правок во всех методах по цепочке при добавлении новых параметров (например, цвета или кодировки).

Как Visitor помогает объединять “родственные операции”? Приведите пример набора операций, которые логично держать в одном посетителе. 
    Он собирает логику одной задачи, размазанную по разным классам, в один модуль. Пример: ValidationVisitor, который проверяет корректность координат, пересечения и выход за границы кадра для всех типов фигур одновременно.

В каких случаях Visitor становится антипаттерном или неоправданным усложнением? Назовите критерии, по которым вы бы отказались от Visitor. 
    Когда иерархия классов элементов часто меняется (добавляются новые типы фигур), или когда операций над ними всего 1–2 и они стабильны. В таких случаях накладные расходы на создание интерфейсов и двойную диспетчеризацию не окупаются.

Почему Visitor особенно хорошо подходит, когда “классы структуры меняются редко, а операции добавляются часто”? Раскройте этот компромисс. 
    Потому что добавление операции — это создание одного нового класса посетителя. Это дешево. Но добавление нового типа элемента требует обновления интерфейса Visitor и всех его реализаций, что крайне трудоемко.

Какие проблемы появляются, если структура классов (ConcreteElement) меняется часто, а посетителей много? Почему это болезненно? 
    Возникает «эффект домино»: добавление одного элемента заставляет программиста зайти в каждый класс посетителя и реализовать там новый метод Visit. Если посетителей десятки, это парализует разработку.

Объясните недостаток Visitor “затрудняется добавление новых ConcreteElement”. Что именно приходится менять и почему это нарушает масштабируемость? 
    Нужно изменить базовый интерфейс Visitor и обновить абсолютно все ConcreteVisitor. Это нарушает масштабируемость, так как стоимость добавления нового типа элемента растет пропорционально количеству уже написанных операций.

Как Visitor может привести к нарушению инкапсуляции? Какие “публичные геттеры” приходится добавлять и почему это может быть плохо? 
    Посетитель находится вне класса элемента, поэтому для работы ему нужны данные этого элемента. Чтобы посетитель мог выполнить задачу, разработчик вынужден открывать внутренние поля через public геттеры, что нарушает принцип сокрытия данных.

В примере ShapeGroup содержит коллекцию Shapes. Как Visitor корректно обходит дерево объектов и почему именно ShapeGroup::Visit() обычно рекурсивен? 
    ShapeGroup::Accept вызывает VisitGroup у посетителя. Посетитель внутри этого метода итерируется по детям группы и вызывает у каждого child->Accept(this). Рекурсия необходима для обработки вложенных структур любой глубины.

В чём разница между Visitor для “плоской коллекции” и Visitor для “иерархии/дерева” объектов? Какие дополнительные вопросы появляются во втором случае? 
    В дереве нужно решать: кто управляет обходом (элемент или посетитель), в каком порядке обходить (pre-order/post-order) и как предотвращать зацикливание, если структура — граф.

Как бы вы реализовали несколько форматов сериализации (XML, JSON, Binary) через Visitor так, чтобы не дублировать общий код (например, обход дерева)? 
    Можно создать базовый класс AbstractSerializerVisitor, который берет на себя логику навигации по структуре объектов, или использовать отдельный класс Traverser, который принимает посетителя и ведет его по дереву.

Объясните, что такое циклическая зависимость между Visitor и ConcreteElement в классическом Visitor. В чём её практический вред? 
    Классы элементов знают об интерфейсе Visitor (для метода Accept), а Visitor знает о классах элементов (параметры Visit). Вред: любая правка в одном месте может потребовать перекомпиляции всей системы из-за тесной связанности заголовочных файлов.

Как работает Acyclic Visitor (ациклический посетитель) и какую проблему он решает по сравнению с классическим Visitor? 
    Он использует пустой базовый интерфейс для посетителя. Конкретные элементы пытаются привести его к нужному им интерфейсу через dynamic_cast. Это разрывает циклическую зависимость: базовый Visitor больше не должен знать о всех типах элементов.

Почему в Acyclic Visitor вводят пустой базовый интерфейс VisitorBase? Какую архитектурную роль он играет? 
    Он служит общим «знаменателем» для метода Accept(VisitorBase&). Это позволяет элементам принимать любой объект-посетитель, не зная его конкретных возможностей до момента выполнения проверки типа.

В Acyclic Visitor элементы используют dynamic_cast для определения, умеет ли посетитель их обрабатывать. Какие плюсы и минусы такого решения? 
    Плюсы: избавляет от необходимости менять все классы при добавлении нового элемента. Минусы: падение производительности из-за RTTI (dynamic_cast) и потеря контроля на этапе компиляции (ошибки отсутствия обработки типа выявляются только в рантайме).

Что произойдёт, если посетитель не поддерживает конкретный тип элемента в Acyclic Visitor? Как это влияет на корректность обхода и ожидания клиента? 
    dynamic_cast вернет nullptr, и элемент просто не будет обработан (проигнорирован). Это удобно для частичных операций, но может привести к скрытым ошибкам, если клиент ожидал полной обработки структуры.

В чём отличие Visitor “на виртуальных методах” от Visitor “на шаблонах” (template-based) в C++? Какие компромиссы по типобезопасности и гибкости? 
    Виртуальный Visitor — динамический (медленнее, но гибче в рантайме). Шаблонный (например, std::visit + std::variant) — статический (максимальная скорость, проверка всех типов при компиляции), но требует знания всех типов элементов заранее.

Как можно реализовать Visitor так, чтобы операции были const-correct (например, Visit(const Rectangle&))? Почему это важно? 
    Нужно перегрузить методы Accept и Visit для const типов. Это важно, так как многие операции (печать, подсчет площади) не должны менять состояние объектов, и использование const гарантирует это на уровне компилятора.

Объясните идею избавления от boilerplate-кода Accept() с помощью Visitable<T, Base> / ConstVisitable<T, Base>. Почему это работает? 
    Создается шаблонный базовый класс, который автоматически реализует метод Accept через приведение this к типу T. Это работает, так как код visitor.Visit(*this) идентичен для всех листовых элементов иерархии.

Почему подход с CRTP в контексте Visitor считается идиомой C++? Какие риски и ограничения он несёт (например, сложность чтения, ошибки наследования)? 
    CRTP позволяет имитировать статическую двойную диспетчеризацию. Риски: усложнение кода шаблонами, риск ошибиться в параметре шаблона Base<Derived>, и потенциальное раздувание бинарного кода (code bloat).

Представьте, что в систему добавляют новый тип фигуры Polygon. Опишите два сценария: а) классический Visitor, б) Acyclic Visitor, и сравните объём изменений, риски и влияние на существующий код. Ответ:

    а) Классический: Нужно изменить интерфейс Visitor и ВСЕ существующие реализации. Огромный риск регрессии и большой объем механической работы.

    б) Ациклический: Нужно создать новый интерфейс IPolygonVisitor. Изменения коснутся только тех посетителей, которые реально должны обрабатывать полигоны. Остальной код остается нетронутым, риск регрессии минимален.