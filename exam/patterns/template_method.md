Паттерн проектирования "Шаблонный метод" (Template Method)

Формальное определение:

    Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма в базовом классе, перекладывая ответственность за реализацию отдельных шагов на подклассы. Паттерн позволяет подклассам переопределять определенные части алгоритма, не изменяя его общую структуру.

Ответы на вопросы

Объясните суть паттерна «Шаблонный метод» и сформулируйте, какой именно тип повторного использования он даёт. 
    Суть в разделении алгоритма на инвариантную часть (скелет) и вариативные части (шаги). Он дает структурное повторное использование: вы переиспользуете общий порядок действий и логику управления, позволяя менять только конкретные детали в наследниках.

Почему «дублирование кода» часто является сигналом к архитектурным изменениям? Какие виды дублирования особенно опасны в OOP? 
    Дублирование увеличивает стоимость сопровождения и риск ошибок при обновлении логики в одном месте, но не в другом. В OOP особенно опасно дублирование поведения (алгоритма) — когда несколько классов выполняют одни и те же шаги в том же порядке, но с небольшими отличиями в деталях.

В «тривиальном решении» (когда PrepareRecipe() виртуальный/абстрактный и реализуется в каждом подклассе) какие проблемы появляются при изменении порядка шагов алгоритма? Объясните на уровне сопровождения и рисков регрессий. 
    Если алгоритм жестко прописан в каждом подклассе, изменение порядка шагов потребует правок во всех N классах-наследниках. Это ведет к высокому риску регрессии: в одном из классов можно легко забыть изменить порядок или допустить опечатку, что приведет к несогласованному поведению системы.

Дайте определение «скелета алгоритма» в Template Method. Как отличить «скелет» от «деталей реализации» в реальном коде? 
    Скелет — это метод базового класса, который вызывает серию других методов в строго определенной последовательности. Отличить просто: скелет — это «оркестратор» (управляет потоком), а детали — это «исполнители» (выполняют конкретную работу, например, запись в БД или вычисление налога).

Почему в классическом Template Method базовый метод-шаблон (PrepareRecipe) часто делают невиртуальным? 
    Чтобы гарантировать неизменность структуры алгоритма. Если сделать метод PrepareRecipe виртуальным, подкласс сможет его переопределить, тем самым нарушив заложенную в базе «политику» и последовательность шагов, что противоречит цели паттерна.

Объясните разницу между абстрактными шагами (pure virtual) и hooks (виртуальные с реализацией по умолчанию). Приведите пример, когда hook лучше абстрактного метода. 
    Абстрактные шаги обязательны для реализации подклассом (нет смысла в алгоритме без них). Hooks предоставляют пустую или стандартную реализацию, которую подкласс может опционально переопределить. Hook лучше, когда шаг является «дополнением» (например, метод OnAfterSave()), который нужен лишь некоторым наследникам.

Придумайте 2–3 разных типа hook’ов в шаблонном методе и поясните их влияние на расширяемость и читаемость. Ответ:

    Control Hook: возвращает bool, позволяя подклассу решить, выполнять ли шаг (например, ShouldFilterData()).

    Interception Hook: выполняется в ключевых точках для логирования или сбора статистики.

    Transformation Hook: позволяет подклассу модифицировать промежуточный результат перед следующим шагом. Они повышают расширяемость, не загромождая основной скелет лишними параметрами.

В примере с CustomerWantsCondiments() какие риски вносит интерактивный ввод/IO в hook? Как бы вы тестировали такой код? 
    Риски: нарушение чистоты логики, блокировка потока выполнения и невозможность автоматизированного тестирования. Для тестирования нужно применить инверсию зависимостей: вынести ввод во внешний объект-провайдер, который в тестах заменяется на Mock (заглушку), возвращающую заранее заданные ответы.

Как Template Method связан с Голливудским принципом («принцип инверсии управления»)? Опишите различие между направлением зависимостей и направлением потока управления. 
    Принцип: «Не звоните нам, мы сами вам позвоним». Базовый класс (высокий уровень) вызывает методы подкласса (низкий уровень). Направление зависимостей: подкласс зависит от базы (наследование). Направление потока: база управляет подклассом, диктуя, когда выполнять шаги.

Сравните DIP и Голливудский принцип: почему можно соблюдать один и нарушать другой? Приведите пример. 
    DIP требует зависимости от абстракций. Голливудский принцип — об управлении. Можно соблюдать DIP (зависеть от интерфейса), но при этом вручную управлять всеми вызовами (нарушить Голливудский принцип). Или наоборот: база управляет подклассом (Голливуд), но жестко зависит от него (нарушение DIP).

Какие антипаттерны/запахи кода могут возникнуть при чрезмерном использовании Template Method? Как их распознать? 
    1. Хрупкий базовый класс: любое изменение в базе ломает всех наследников. 2. Раздутая иерархия: слишком много мелких классов для простых задач. 3. Пустые реализации: подклассы вынуждены реализовывать абстрактные методы, которые им не нужны (нарушение LSP).

Какие требования к контракту (pre/post conditions, инварианты) особенно важны в Template Method? Где их лучше фиксировать: в базовом методе или в шагах? Почему? 
    Важна согласованность данных между шагами. Контракты лучше фиксировать в базовом методе (шаблоне) с помощью assert или исключений до и после вызова вариативных шагов. Это гарантирует, что любой подкласс не нарушит общее состояние системы.

Что такое идиома NVI (Non-Virtual Interface) и чем она отличается по фокусу от Template Method? В каких случаях NVI предпочтительнее? 
    NVI — это практика в C++, где публичные методы интерфейса всегда невиртуальные, а для расширения используются приватные виртуальные методы. Фокус Template Method шире (структура алгоритма), а NVI — на защите интерфейса класса. NVI предпочтительнее почти всегда для обеспечения стабильности публичного API.

Разберите пример Document::Save() (NVI): какие элементы “политики” централизованы в невиртуальном методе и почему это полезно для качества системы? 
    В Save() могут быть: проверка прав доступа, блокировка файла, логирование начала и конца операции, обработка общих исключений. Это полезно, так как наследники не могут «забыть» проверить права или записать лог, что гарантирует соблюдение корпоративных политик безопасности и надежности.

Почему сочетание virtual + default arguments в C++ опасно? Объясните механизм привязки значений по умолчанию и покажите, как NVI решает проблему. 
    Значения по умолчанию привязываются статически (на этапе компиляции по типу указателя), а виртуальный вызов — динамически. Можно вызвать метод подкласса, но с аргументом по умолчанию от базы. NVI решает это: невиртуальный публичный метод содержит значение по умолчанию и передает его в виртуальный защищенный метод уже как обычный аргумент.

Какие шаги в Template Method стоит делать private, какие protected, а какие public? Обоснуйте с точки зрения инкапсуляции и защиты контракта. Ответ:

    Public: Только сам шаблонный метод (интерфейс для клиента).

    Protected: Шаги и hooks (чтобы наследники могли их переопределить).

    Private: Внутренние вспомогательные методы базы, которые наследникам менять запрещено.

Опишите типичные ошибки проектирования Template Method в C++: вызов виртуальных методов из конструктора/деструктора, “обходные” публичные виртуальные методы, нарушение инвариантов. Почему они опасны? 
    Вызов виртуального метода в конструкторе C++ вызовет версию метода базового класса, а не наследника (так как наследник еще не создан). Это ведет к логическим ошибкам или падениям. «Обходные» методы разрушают инкапсуляцию, позволяя клиенту вызвать шаг алгоритма в обход самого шаблона.

Допустим, в шаблонном методе есть шаг, который должен быть выполнен ровно один раз (идемпотентность/инициализация). Где лучше хранить состояние и как избежать “частично инициализированного” объекта? 
    Состояние (флаг m_isInitialized) нужно хранить в базовом классе. Проверку флага нужно делать внутри самого шаблонного метода. Это гарантирует, что логика «выполнить один раз» централизована и не зависит от добросовестности разработчика подкласса.

Придумайте пример, где Template Method конфликтует с LSP (принцип подстановки Лисков). Что именно должен “сломать” подкласс, чтобы нарушить LSP? 
    Пример: базовый класс требует, чтобы шаг Step1() возвращал положительное число. Если подкласс переопределяет его и возвращает -1 или выбрасывает исключение там, где оно не предусмотрено, он ломает ожидания базового алгоритма, нарушая LSP.

Как бы вы документировали точки расширения Template Method, чтобы избежать “магии фреймворка” и скрытых зависимостей порядка вызовов? 
    Использовать четкий именованный стандарт для hooks (например, префиксы On... или Before.../After...). В документации к базовому классу явно указывать post-conditions для каждого шага и запрещать зависимости между вариативными шагами (шаг Б не должен ожидать, что шаг А что-то записал в переменную).

В каких ситуациях Template Method лучше заменить на Strategy? Сформулируйте критерии выбора. Ответ:

    Если нужно менять алгоритм в runtime (динамически).

    Если иерархия наследования становится слишком глубокой.

    Если части алгоритма нужно переиспользовать в других иерархиях. Критерий: наследование (TM) — для статичных связей «IS-A»; композиция (Strategy) — для гибких «HAS-A».

Как Template Method соотносится с Factory Method? Приведите сценарий, когда Template Method вызывает фабричный метод на одном из шагов. 
    Factory Method часто является шагом в Template Method. Сценарий: Шаблонный метод OrderPizza() выполняет шаги: CreatePizza() (это Factory Method), Bake(), Cut(), Box(). Конкретный магазин сам решает, какую пиццу создать, но процесс обработки един.

В примере “напитков” добавьте шаг “подогреть чашку” или “проверить наличие ингредиентов”. Куда вы его добавите и почему? 
    CheckIngredients() — как абстрактный шаг в самое начало PrepareRecipe(), чтобы не тратить ресурсы, если чего-то нет. WarmCup() — как hook перед наливанием в чашку, так как это опциональное улучшение, не влияющее на суть напитка.

Опишите compile-time Template Method (CRTP): как переносится диспетчеризация из рантайма в компилятор? Какие требования предъявляются к Derived? 
    Используется шаблон: class Derived : public Base<Derived>. В Base метод-шаблон делает static_cast<T*>(this)->Step(). Диспетчеризация происходит при компиляции. Требование: Derived должен реализовать все методы, которые вызывает Base, иначе код не скомпилируется.

Какие ограничения CRTP-варианта критичны для архитектуры? Как бы вы смягчали эти ограничения? 
    Ограничения: нет динамического полиморфизма (нельзя хранить Base* на разные Derived в одном векторе), раздувание бинарного кода (code bloat). Смягчение: использование общей невиртуальной базы без шаблонов для хранения указателей, если это необходимо.

Почему “нестатические методы наследника нельзя вызывать из конструктора/деструктора родителя” особенно важно в CRTP-варианте? Приведите пример бага и способ избежать. 
    В CRTP при вызове из конструктора базы объект Derived еще не создан. Если Base вызовет static_cast<T*>(this)->Step(), это приведет к неопределенному поведению (UB), так как мы обращаемся к полям, которых нет. Избежать: никогда не вызывать «виртуальные» методы CRTP в конструкторе.

Спроектируйте Template Method для Undo/Redo (команды): какие шаги должны быть инвариантными, а какие — вариативными? 
    Инварианты: проверка возможности отката, запись в лог, обновление стека команд. Вариативные: DoWork() и UndoWork(). Сама команда предоставляет логику «как отменить», а базовый менеджер команд обеспечивает «скелет» процесса (сохранение состояния до/после).

Приведите пример Template Method в UI/веб-фреймворке (pipeline обработки события/запроса). Какие hooks там обычно предоставляют, и какие риски создаёт неправильное использование hooks? 
    Пример: жизненный цикл компонента в React или обработка запроса в ASP.NET (Middleware). Hooks: BeforeAction, AfterAction. Риски: если hook в Middleware «зависнет» или не вызовет следующую стадию, весь запрос оборвется; изменение заголовков в AfterAction, когда тело уже отправлено.

Представьте, что вам нужно обеспечить единые политики для набора операций, где часть шагов вариативна. Как бы вы совместили Template Method и NVI так, чтобы подклассы не могли “обойти” политику? 
    Создать публичный final метод (Template), который вызывает приватные/защищенные virtual методы (шаги). Между вызовами шагов жестко вшить вызовы методов-политик (логирование, валидация). Поскольку методы-политики приватные и невиртуальные, наследник физически не может их переопределить или вызвать шаги без них.