Паттерны проектирования «Команда» и «Хранитель»
Паттерн проектирования "Команда"

Объясните, какую архитектурную проблему решает паттерн Command и почему прямой вызов методов получателя из UI считается плохим решением. Паттерн решает проблему жесткой связности между объектом, инициирующим запрос (UI), и объектом, который его выполняет (бизнес-логика). Прямой вызов плох тем, что UI становится зависимым от конкретных классов логики, что затрудняет повторное использование UI-элементов, реализацию очередей, логирования и отмены действий.

В чём различие ролей Client, Invoker, Command, Receiver? Приведите пример для каждого участника из системы “меню → робот”.

    Client: Создает конкретную команду и назначает ей получателя (Инженер, настраивающий пульт).

    Invoker: Инициатор вызова, хранит команду и просит её выполниться (Кнопка в меню пульта).

    Command: Интерфейс с методом execute() (Обстрактная команда «Действие»).

    Receiver: Тот, кто реально знает, как выполнить работу (Сам Робот).

Почему инициатор (Invoker) не должен создавать команды? Какие зависимости возникнут, если он будет знать конкретные классы команд? Инициатор должен быть универсальным компонентом (например, графическая кнопка). Если он будет создавать команды сам, он «узнает» о конкретных классах бизнес-логики. Это сделает невозможным использование одной и той же кнопки для разных действий без переписывания её кода.

Какие преимущества даёт то, что запрос представлен объектом (Command), а не вызовом метода? Назовите минимум 3 практических эффекта.

    Отложенное выполнение: Команду можно положить в очередь и выполнить позже.

    История действий: Объекты команд можно хранить в стеке для реализации Undo/Redo.

    Логирование: Команды можно сериализовать и записывать в файл для восстановления системы после сбоя.

Что именно должно храниться внутри объекта команды: получатель, параметры, логика, состояние? Обоснуйте распределение ответственности. В команде должны храниться ссылка на Получателя и параметры, необходимые для вызова его методов. Логика «как делать» должна оставаться в Получателе. Состояние может храниться в команде только если оно нужно для отмены действия (Undo).

Объясните, что означает “ослабление связности” в контексте Command. Какая связность уменьшается и какие зависимости остаются? Уменьшается связность между UI и бизнес-логикой. UI (Invoker) теперь зависит только от абстрактного интерфейса Command. Прямая зависимость UI от Receiver исчезает. Остается зависимость Client от всех компонентов, так как он их собирает вместе.

Как паттерн Command помогает реализовать конфигурирование действий (например, связывание фраз с командами в меню)? Поскольку команда — это объект, его можно передавать как параметр. Можно создать карту (Map), где ключом будет строка (фраза меню), а значением — объект команды. Это позволяет менять поведение меню в рантайме без изменения кода классов.

Как бы вы расширили пример с роботом, чтобы добавить команду “идти 10 секунд”, не меняя код меню? Какие параметры и где вы бы хранили? Я бы создал новый класс WalkCommand, реализующий Command. В конструктор я бы передал ссылку на робота и число 10 (длительность). Эти данные хранились бы в полях класса WalkCommand. Код меню останется прежним, так как оно работает с интерфейсом Command.

В каких случаях команда может быть реализована не классом, а функциональным объектом (std::function, лямбда)? Какие плюсы и минусы у такого подхода? Это оправдано для простых, необратимых действий без состояния.

    Плюсы: Меньше кода (нет нужды плодить классы), лаконичность.

    Минусы: Сложно реализовать undo(), невозможно хранить дополнительные метаданные или сериализовать лямбду.

Как изменится тестируемость системы при переходе от прямых вызовов к Command? Какие части станет легче мокать и проверять? Тестируемость улучшается. Можно тестировать команды изолированно, подкладывая Mock-объект вместо реального Receiver. Можно проверять Invoker, подкладывая Mock-команду и проверяя, был ли вызван метод execute().

Опишите архитектуру Undo/Redo на базе Command: какие структуры данных нужны и какие операции выполняются при Undo и Redo. Нужны два стека: Undo stack и Redo stack.

    Выполнение: Команда выполняется, execute() кладет её в Undo stack, Redo stack очищается.

    Undo: Команда достается из Undo stack, вызывается unexecute(), команда кладется в Redo stack.

    Redo: Команда достается из Redo stack, вызывается execute(), команда кладется в Undo stack.

Почему не каждая операция естественно обратима? Приведите примеры команд, для которых сложно или дорого реализовать Unexecute(). Некоторые действия разрушительны или зависят от внешнего мира.

    Примеры: Удаление файла без возможности восстановления, отправка Email, запрос к датчику (состояние мира уже изменилось), сложные нелинейные вычисления.

Объясните, как реализовать макрокоманду с возможностью отката изменений? Макрокоманда должна хранить список (вектор) команд. Метод execute() вызывает execute() у всех в цикле (от первой к последней). Метод unexecute() должен вызывать unexecute() у всех команд в обратном порядке (от последней к первой).

Что такое макрокоманда и какие паттерны в ней сочетаются? Это команда, которая выполняет группу других команд. Здесь сочетаются паттерны Команда и Компоновщик (Composite), так как макрокоманда сама является командой и содержит другие команды.

Как бы вы реализовали макрокоманду так, чтобы при ошибке в середине выполнения система оставалась в консистентном состоянии? Нужно обернуть цикл выполнения в блок try-catch. Если i-я команда упала, нужно запустить цикл от i−1 до 0 и вызвать unexecute() у всех уже выполненных команд. Это обеспечит атомарность (все или ничего).

В чём проблема “избыточной истории изменений” в редакторах и почему она ухудшает UX Undo/Redo? Если записывать каждое нажатие клавиши как отдельную команду, пользователю придется нажать Ctrl+Z 100 раз, чтобы отменить одно написанное слово. Это раздражает и делает историю практически бесполезной.

Объясните идею склеивания (coalescing) соседних команд редактирования. По каким признакам можно понять, что команды нужно объединить? Идея в том, чтобы объединять мелкие правки в одну логическую операцию. Признаки: команды идут подряд, выполнены за короткий промежуток времени, относятся к одному и тому же участку текста/объекту.

Чем отличаются стратегии AddEdit() и ReplaceEdit() при работе с историей изменений в примере из лекции? В каких случаях полезна каждая из них?

    AddEdit: Всегда добавляет новую запись в историю. Полезна для явно разных действий (выделить жирным, затем сменить шрифт).

    ReplaceEdit: Пытается поглотить новую команду старой (например, дописать букву в текущую команду ввода текста). Полезна для непрерывного ввода текста.

В примере EditText::ReplaceEditImpl() используется сравнение otherEditText->m_newText == m_oldText. Почему это важная проверка и какую семантику она выражает? Это проверка непрерывности. Она гарантирует, что «новое состояние» предыдущей команды совпадает с «исходным состоянием» текущей. Это выражает семантику того, что цепочка изменений не была прервана другими действиями.

Какие риски появляются при “умных командах”, которые пытаются оптимизировать историю (например, склеивание)? Как это может повлиять на корректность Undo/Redo? Риск — потеря промежуточных состояний, которые могли быть важны. Если алгоритм склеивания ошибочен, unexecute() может вернуть систему в некорректное состояние, не соответствующее тому, что было на самом деле.

Опишите две крайности “интеллектуальности команд” и объясните, почему они вредны с точки зрения принципов ООП и SOLID.

    Тупая команда: Просто вызывает метод получателя. Вред: логика Undo/Redo размазывается по системе.

    Толстая (умная) команда: Содержит в себе всю бизнес-логику, игнорируя Receiver. Вред: нарушение SRP, дублирование логики, команда становится труднотестируемой.

Где должна находиться бизнес-логика: в команде или в получателе? Приведите критерии принятия решения. В Получателе. Команда — это лишь транспорт для вызова. Критерий: если логику можно переиспользовать без команды — она должна быть в Получателе. Если логика касается только управления историей — она может быть в команде.

Какие дополнительные возможности появляются, если команды можно сериализовать и десериализовать? Какие ограничения это накладывает на дизайн команд? Возможности: сохранение макросов в файл, передача команд по сети (RPC), создание системы логов для восстановления. Ограничения: команды не могут хранить живые указатели/ссылки (только ID объектов), все параметры должны быть сериализуемыми.

Как реализовать асинхронное выполнение команд (очередь задач, выполнение в другом потоке)? Нужен поток-воркер и потокобезопасная очередь команд (Thread-safe queue). Invoker кладет команду в очередь, а воркер в цикле достает их и вызывает execute().

Чем Command-подход к Undo/Redo отличается от подхода “сохранить снимок состояния”? В каких случаях Command выгоднее? Command хранит дельту (действие), а снимок — всё состояние. Command выгоднее, когда объект очень большой (например, 3D-модель), а изменения в нем маленькие (сдвиг на 1 мм). Снимки в таком случае быстро забьют память.
Паттерн проектирования "Хранитель" (Memento)

Сформулируйте идею паттерна Memento и объясните, как он сохраняет инкапсуляцию. Идея в том, чтобы сохранить состояние объекта во внешнем хранилище так, чтобы структура этого состояния осталась неизвестна никому, кроме самого объекта. Инкапсуляция сохраняется за счет того, что объект Memento предоставляет «широкий» интерфейс для создателя и «узкий» (пустой) для всех остальных.

Опишите роли Originator, Memento, Caretaker и их взаимодействие. Кто имеет право читать/изменять состояние?

    Originator: Объект, состояние которого нужно сохранить. Только он может читать/писать данные в Memento.

    Memento: Непрозрачный объект со снимком состояния.

    Caretaker: Опекун, хранит Memento, но не знает, что внутри. Только Originator имеет право доступа к данным.

Почему “классическая версия” Memento может потенциально нарушать инкапсуляцию, и как “альтернативная версия” решает эту проблему? Классическая версия часто полагается на механизмы языка (вроде friend в C++), что создает жесткую связь. Альтернативная версия использует пустые интерфейсы-маркеры. Caretaker видит только интерфейс IMemento, а Originator при получении делает dynamic_cast к своей конкретной реализации.

В каких случаях Memento может быть слишком дорогим по памяти? Какие оптимизации можно применить? Когда состояние объекта огромно, а снимки делаются часто. Оптимизации: хранение только инкрементальных изменений (разницы), сжатие данных снимка, ограничение глубины истории.

Спроектируйте систему Undo/Redo для редактора, где часть операций реализована через Command, а часть — через Memento. Как бы вы комбинировали их и почему? Я бы использовал Command для простых геометрических операций (перемещение, поворот) — это дешево. Memento я бы использовал для сложных операций, которые трудно обратить математически (например, фильтр «размытие» или сложная деформация сетки). Команда в методе execute() просто просила бы Originator создать Memento и сохраняла бы его в себе.