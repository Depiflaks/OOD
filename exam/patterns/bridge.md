Паттерн проектирования "Мост"

Объясните, в чём состоит ключевая идея паттерна «Мост» и какую проблему проектирования он решает. 
    Ключевая идея — разделение одной большой иерархии на две независимые: абстракцию и реализацию. Он решает проблему «взрывного» роста количества классов (комбинаторного взрыва), возникающую при попытке расширять функциональность объекта в нескольких независимых измерениях одновременно через наследование.

Что в паттерне «Мост» является абстракцией, а что — реализацией? Приведите пример на основе окон GUI. 
    Абстракция — это высокоуровневый интерфейс и логика (например, класс Window, описывающий типы окон: DialogWindow, IconWindow). Реализация — это низкоуровневые примитивы, зависящие от платформы (например, интерфейс WindowImp и его наследники WinWindowImp, LinuxWindowImp, выполняющие отрисовку линий и текста).

Почему добавление новой платформы (например, MacOS X) приводит к “взрыву количества классов” в наивной реализации UI-библиотеки? 
    В наивной реализации через наследование каждый вид окна должен иметь версию для каждой платформы. Если у нас N видов окон и M платформ, общее число классов составит N×M. При добавлении одной платформы нужно создать N новых классов.

Какие признаки в коде и структуре классов подсказывают, что пора применять «Мост»? 
    Наличие классов с названиями типа ShapeWindows, ShapeLinux или RectangleRaster, RectangleVector. Также признаком является раздутая иерархия, где изменения в логике (например, новый вид фигуры) требуют создания множества классов под каждую среду исполнения.

Что означает фраза: «Абстракция и реализация должны расширяться независимо»? Объясните на примере. 
    Это значит, что добавление нового типа абстракции не требует изменения кода реализации, и наоборот. Пример: при добавлении фигуры Triangle (абстракция) нам не нужно дописывать код в VulkanRenderer или DirectXRenderer (реализации). При добавлении MetalRenderer нам не нужно менять классы существующих фигур.

Какие риски возникают для сопровождения и тестирования, если клиентский код зависит от классов конкретной платформы? 
    Код становится непереносимым. Тестирование требует наличия специфической среды (ОС или оборудования). Любое изменение в API платформы вызывает каскадные правки в бизнес-логике клиента.

Почему фабрика сама по себе не решает проблему сильной связности абстракции и реализации? 
    Фабрика помогает только в создании объекта. Если структура классов жестко связана через наследование (например, CircleWin), фабрика просто скроет вызов new, но вам всё равно придется поддерживать огромную сетку классов N×M.

Опишите структуру паттерна Bridge (Abstraction, RefinedAbstraction, Implementor, ConcreteImplementor) и ответственность каждого элемента. 
    * Abstraction: определяет базовый интерфейс и хранит ссылку на Implementor.

    RefinedAbstraction: расширяет интерфейс абстракции (логика «что сделать»).

    Implementor: определяет интерфейс для классов реализации (примитивы «как сделать»).

    ConcreteImplementor: содержит конкретный платформозависимый код.

Какой тип связи между Window и WindowImp является ключевым в паттерне «Мост» и почему? 
    Композиция (или агрегация). Абстракция Window содержит указатель/ссылку на WindowImp. Это позволяет менять реализацию динамически во время выполнения и избавляет от жесткой связи, характерной для наследования.

Какие два “непересекающихся измерения” чаще всего выделяют при применении Bridge? Приведите 2–3 пары. 
    1) Геометрические фигуры (логика) и API отрисовки (рендеринг). 2) Типы уведомлений (SMS, Email) и службы доставки (провайдеры). 3) Пульты управления (интерфейс) и бытовая техника (исполнение).

Почему в Bridge обычно используется композиция, а не наследование? Какие преимущества это даёт с точки зрения ООП? 
    Композиция позволяет менять поведение объекта в рантайме и делает иерархии более плоскими. Это следует принципу «предпочитайте композицию наследованию», уменьшая зацепление (coupling) и упрощая повторное использование кода.

Объясните, как Bridge помогает следовать принципу Open/Closed (OCP). 
    Система открыта для расширения: вы можете добавлять новые абстракции или реализации, просто создавая новые классы. При этом она закрыта для модификации: существующие классы не нужно менять при добавлении элементов в параллельную иерархию.

Представьте, что вам нужно добавить новый тип окна (например, PopupWindow) и новую платформу (Wayland). Какие классы изменятся при использовании Bridge и какие — при наследовании без Bridge? 
    С Bridge: добавится 1 класс PopupWindow и 1 класс WaylandImp (всего 2). Без Bridge: добавится класс PopupWindowWayland, а также версии PopupWindow для всех старых платформ и версии старых окон для Wayland (всего N+M новых классов).

Как в Bridge организовать возможность выбора реализации во время выполнения? Приведите сценарий, где это реально нужно. 
    Через сеттер или передачу нужного Implementor в конструктор абстракции. Сценарий: переключение игры с режима OpenGL на Vulkan в настройках без перезапуска логики игровых объектов.

Какие недостатки паттерна «Мост» проявляются в небольших проектах и почему его иногда считают “overengineering”? 
    Усложнение архитектуры из-за введения дополнительных интерфейсов и косвенности (индирекции). В простых задачах, где платформа всего одна, это создает лишний код и затрудняет понимание системы новичками.

В каких случаях Implementor стоит делать интерфейсом, а в каких — обычным классом? Обоснуйте архитектурно. 
    Интерфейсом — когда реализации радикально отличаются по коду. Абстрактным классом — если между ними есть общая логика или состояние, которое можно вынести вверх для исключения дублирования.

Кто должен создавать ConcreteImplementor в Bridge: сама Abstraction, клиент, фабрика или DI-контейнер? Сравните варианты и их последствия. 
    Сама Abstraction — плохо (жесткая связь). Клиент — гибко, но раскрывает детали. Фабрика — хороший баланс. DI-контейнер — лучший вариант для слабой связности и удобства автоматизированного тестирования.

В лекции упоминается совместное использование реализаций между несколькими объектами абстракции. Зачем это может быть нужно и какие проблемы при этом возникают? 
    Нужно для экономии ресурсов (память, дескрипторы). Проблемы: необходимость управления жизненным циклом (кто удаляет?), потокобезопасность и риск того, что изменение состояния реализации одним объектом повлияет на другие.

Как вы бы реализовали Bridge так, чтобы одна реализация могла безопасно использоваться несколькими абстракциями? 
    Использовать умные указатели с подсчетом ссылок (std::shared_ptr) и проектировать реализацию как неизменяемую (Immutable) или обеспечивать строгую синхронизацию доступа.

Сравните паттерны Bridge и Adapter: чем отличается их цель, когда они применяются и что происходит с зависимостями в системе? 
    Bridge проектируется заранее, чтобы разделить интерфейс и реализацию. Adapter применяется постфактум, чтобы заставить несовместимые интерфейсы работать вместе. Bridge увеличивает гибкость, Adapter устраняет несовместимость.

Объясните, как паттерн Builder может быть “построен в виде моста”: кто играет роль абстракции и кто — реализации? 
    Director в этом случае выступает как Абстракция (логика сборки, не знающая деталей), а Builder — как Реализация (конкретное исполнение шагов конструирования). Это позволяет независимо менять алгоритм сборки и способ представления продукта.