Паттерн проектирования "Декоратор" (Decorator)

Формальное определение:

    Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новые обязанности, оборачивая их в объекты-обертки. Он предоставляет гибкую альтернативу наследованию для расширения функциональности.

Объясните, какую проблему решает паттерн «Декоратор» и почему попытка решить её только наследованием приводит к «комбинаторному взрыву» классов: 
    Декоратор позволяет добавлять обязанности объекту во время выполнения, не меняя его класс. Наследование статично: для каждой комбинации свойств (например, Кофе + Молоко, Кофе + Корица) пришлось бы создавать отдельный класс. При n добавках количество классов растет экспоненциально (2n), что делает поддержку системы невозможной.

В чём ключевое отличие «расширения поведения» через декоратор от «расширения поведения» через наследование? Приведите пример из домена «кофейня»: 
    Отличие в моменте связывания: наследование расширяет поведение на этапе компиляции, а декоратор — на этапе выполнения. Пример: Вместо создания класса EspressoWithMilk (наследование), мы берем объект Espresso и «оборачиваем» его в объект MilkDecorator (декоратор) прямо в коде заказа.

Опишите роли участников паттерна Decorator (Component, ConcreteComponent, Decorator, ConcreteDecorator) и сопоставьте их с вашими классами напитков/добавок:

    Component: Общий интерфейс напитков (Beverage).

    ConcreteComponent: Конкретный напиток без добавок (Espresso).

    Decorator: Базовый класс для всех добавок (CondimentDecorator), хранящий ссылку на Beverage.

    ConcreteDecorator: Конкретная добавка (Milk, Sugar), реализующая добавление стоимости и описания.

Почему важно, что декоратор имеет тот же тип (реализует тот же интерфейс), что и декорируемый объект? Как это связано с полиморфизмом и LSP: 
    Это позволяет использовать декоратор везде, где ожидается базовый компонент. Благодаря полиморфизму клиент не замечает подмены. Это соответствует принципу подстановки Лисков (LSP): обернутый объект остается полноправным представителем своего базового типа.

Объясните, как в цепочке декораторов вычисляется стоимость напитка (по шагам), и какие гарантии корректности даёт такая структура:

    Вызывается GetCost() самого внешнего декоратора.

    Он делегирует вызов вложенному объекту.

    Процесс повторяется до ConcreteComponent (базового напитка).

    Базовый напиток возвращает цену, и каждый декоратор в цепочке прибавляет к ней свою стоимость. Структура гарантирует, что каждая обертка добавит свою цену ровно один раз.

Какие признаки подсказывают, что в задаче следует применить декоратор, а не просто добавить методы в базовый класс:

    Обязанности могут добавляться и сниматься динамически.

    Существует множество независимых расширений, которые могут комбинироваться.

    Добавление всех методов в базовый класс сделает его слишком тяжелым (нарушение SRP).

Сравните подход «флаги в базовом классе» и подход «декораторы»: какие риски и ограничения есть у каждого, и почему флаги нарушают OCP: 
    Флаги требуют изменения кода базового класса при добавлении каждой новой опции (нарушение OCP). Декораторы позволяют добавлять новые опции, создавая новые классы. Флаги ограничивают систему (нельзя добавить две порции молока), а декораторы позволяют строить цепочки любой глубины.

Какие «странные комбинации» появляются при реализации через флаги? Как в декораторе можно ограничивать/валидировать недопустимые комбинации: 
    С флагами легко получить «Чай с двойным льдом», если это не предусмотрено логикой. В декораторе валидация возможна в конструкторе: можно проверить тип вложенного объекта (через dynamic_cast или метаданные) и запретить оборачивание, если компоненты несовместимы.

Объясните принцип Open/Closed (OCP) на примере добавления новой добавки (например, «ванильный сироп»): что нужно менять в варианте с флагами и что — в варианте с декоратором: 
    В варианте с флагами нужно модифицировать существующий класс Beverage (добавить поле и изменить GetCost). В варианте с декоратором мы создаем новый класс VanillaDecorator, не меняя ни строчки существующего кода.

Почему композиция считается более гибкой, чем наследование, в контексте динамического добавления поведения? Приведите пример «во время выполнения»: 
    Композиция позволяет менять связи между объектами прямо в рантайме. Пример: В текстовом редакторе мы можем добавить объекту TextArea декоратор Scrollbar только тогда, когда текст перестал помещаться в окне.

Какие недостатки могут появиться у декоратора по сравнению с наследованием (производительность, отладка, сложность), и как их обычно смягчают: 
    Недостатки: большое количество мелких объектов, сложность отладки цепочек («матрешка»), накладные расходы на виртуальные вызовы. Смягчение: использование паттернов «Фабрика» или «Строитель» для скрытия процесса сборки слоеных объектов.

В каких случаях использование декоратора будет избыточным? Назовите критерии и приведите пример: 
    Если вариантов расширения всего 1-2 и они статичны (не комбинируются). Критерий: принцип YAGNI. Пример: Кофе, который бывает только «горячий» или «холодный» и никогда не меняет это состояние.

Чем декоратор отличается от прокси и адаптера, если внешне они могут выглядеть похоже (обёртка вокруг объекта):

    Адаптер: Меняет интерфейс (делает его совместимым).

    Прокси: Контролирует доступ к объекту (безопасность, ленивая загрузка).

    Декоратор: Добавляет новую функциональность в рамках того же интерфейса.

Почему в CondimentDecorator методы GetDescription() и GetCost() целесообразно сделать final: 
    Это предотвращает случайное нарушение логики делегирования в подклассах (ConcreteDecorators). Если их переопределить неправильно, цепочка вызовов может разорваться, и стоимость вложенных объектов не будет учтена.

Объясните, как в CondimentDecorator проявляется паттерн «Шаблонный метод»: где «скелет алгоритма», а где «шаги, делегируемые подклассам»: 
    GetCost() — это скелет: он вызывает m_component->GetCost() и прибавляет результат специфического шага GetCondimentCost(). Конкретные добавки реализуют только этот «шаг», не меняя общую логику обхода цепочки.

Почему «шаги алгоритма» (GetCondimentCost, GetCondimentDescription) можно сделать private virtual? Какие архитектурные преимущества это даёт: 
    Это паттерн NVI (Non-Virtual Interface). Базовый класс полностью контролирует поток выполнения (оркестрацию), а наследники лишь предоставляют данные. Это защищает инварианты класса.

Как бы вы реализовали «двойную порцию шоколада» в модели с декораторами? Приведите минимум два подхода и сравните их:

    Повторное оборачивание: Chocolate(Chocolate(Espresso)). Преимущество: простота, чистота паттерна.

    Параметр в декораторе: Chocolate(Espresso, quantity=2). Преимущество: меньше объектов в памяти. Первый подход более гибкий и соответствует духу декоратора.

Какие требования к владению объектом и управлению временем жизни возникают при реализации декоратора? Почему в примере используется unique_ptr: 
    Декоратор должен владеть оборачиваемым объектом. unique_ptr гарантирует, что при удалении декоратора вся цепочка вложенных объектов будет корректно удалена автоматически, предотвращая утечки памяти.

Что изменится, если вместо unique_ptr использовать shared_ptr? Какие новые риски и возможности это создаст для цепочек декораторов: 
    Появится возможность совместного владения (несколько декораторов ссылаются на один напиток). Риск: случайное изменение общего состояния или создание циклов владения.

Как декоратор влияет на тестируемость системы? Опишите стратегию юнит-тестирования для базового напитка и для конкретной добавки-декоратора: 
    Тестируемость улучшается. Базовый напиток тестируется отдельно. Декоратор тестируется путем оборачивания в него Mock-объекта компонента, чтобы проверить, что декоратор корректно добавляет свои данные к результатам Mock-а.

Как можно реализовать «снятие декорации» (unwrap) или интроспекцию цепочки декораторов, не нарушая инкапсуляцию: 
    Можно добавить в интерфейс метод GetWrappedComponent() или реализовать паттерн «Посетитель» (Visitor) для обхода всей цепочки и анализа типов без прямого доступа к приватным полям.

Какие ошибки проектирования часто допускают при внедрении декоратора (например, «захардкодить цены в одном месте», «слишком много обязанностей»)? Как их избежать: Ошибки: зависимость декоратора от конкретного класса компонента, а не от интерфейса; передача состояния через цепочку. Избегать: держать декораторы «тонкими», использовать внешние конфиги для цен.

В примере со строками StringTransformer играет роль «интерфейса компонента». Какие свойства должны быть у такого интерфейса, чтобы декораторы хорошо композировались: Интерфейс должен быть идемпотентным или иметь предсказуемые побочные эффекты. Методы должны принимать и возвращать данные одного типа (например, string), чтобы результат одного декоратора мог служить входом для другого.

Почему ручная комбинация преобразователей строк (функции типа UpperCaseWithSquareBrackets) приводит к той же проблеме, что и наследование в примере кофейни: Потому что для каждой новой комбинации преобразований (например, инверсия + скобки) придется писать новую функцию. Это ведет к дублированию кода и взрывному росту количества функций.

Объясните, что делает функция Decorate(t, d) в функциональном стиле и как она связана с идеей «оборачивания» в ООП-декораторе: Функция создает замыкание, которое сначала вызывает исходное преобразование t, а затем применяет к результату новое преобразование d. Это функциональный аналог вложения одного объекта в другой.

В Decorate используется перемещение и forward. Какие проблемы с производительностью/корректностью решает perfect forwarding в таком коде: Perfect forwarding позволяет передавать аргументы в функции-обертки без лишнего копирования и с сохранением категории значения (lvalue/rvalue). Это критично для тяжелых объектов, таких как длинные строки.

Какой смысл несёт «синтаксический сахар» (например, оператор | для строковых декораторов или << для напитков)? Какие риски он несёт для читаемости и поддержки: Смысл: наглядность построения цепочки (DSL). Риск: перегрузка операторов может скрыть факт создания новых объектов и выделения памяти, что затруднит поиск утечек или узких мест производительности.

Приведите пример из реальной разработки, где декоратор используется повсеместно (например, middleware, I/O streams). Объясните, как там устроена «цепочка» и что именно добавляют декораторы: В Java или C++ I/O: BufferedInputStream(FileInputStream). Базовый поток читает байты, декоратор добавляет буферизацию. В Web-разработке (Middleware): каждый слой (Auth, Logging) декорирует обработку HTTP-запроса, добавляя свои действия перед передачей запроса дальше.

Предложите дизайн декоратора для HTTP-клиента, который добавляет авторизацию, логирование и кэширование. Как вы определите порядок декораторов и почему: Порядок: Logging(Caching(Authorization(HttpClient))). Логирование — внешнее (чтобы видеть все попытки), Кэширование — до Авторизации (чтобы не авторизовываться, если данные есть в кэше).

Представьте, что нужно добавить новое требование: «некоторые добавки конфликтуют друг с другом» и «цены зависят от времени суток». Как бы вы расширили решение на декораторах: Для конфликтов: добавить метод GetTags() в интерфейс и проверять наличие конфликтующих тегов в конструкторе декоратора. Для цен: передавать объект Context (с временем суток) во все вызовы GetCost(Context context).