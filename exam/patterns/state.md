Паттерн проектирования «Состояние»

Что именно считается «внутренним состоянием» объекта в паттерне State и чем оно отличается от обычных полей класса? 
    Это совокупность данных и логики, определяющая текущий режим поведения объекта. В отличие от обычных полей (примитивов), это состояние инкапсулировано в отдельный объект-делегат, что позволяет менять алгоритмы работы целиком, а не просто значения переменных.

Почему реализация автомата через switch(m_state) быстро деградирует при добавлении новых состояний и действий? Приведи конкретные причины. 
    1. Раздувание методов: каждый метод превращается в огромный список case. 2. Дублирование: логика переходов размазана по всем методам. 3. Сложность отладки: трудно проследить целостность переходов. 4. Хрупкость: легко забыть обновить один из десяти switch при добавлении нового состояния.

Какие изменения в коде автомата придётся сделать, если добавить новое состояние (например, “WinnerState” — выдаёт 2 жвачки за одну монету) в варианте со switch? 
    Нужно: 1. Добавить значение в enum State. 2. Во всех существующих методах (insertCoin, ejectCoin, turnCrank, dispense) добавить новый блок case WINNER:, прописав там логику реакции на действие.

В чём заключается нарушение принципа Open/Closed в реализации с enum State и switch? Почему это опасно на практике? 
    Нарушение в том, что для расширения функционала (новое состояние) нужно изменять (модифицировать) уже протестированный код основного класса. Это опасно появлением регрессионных ошибок в стабильных частях системы при добавлении новых фич.

Опиши роль Контекста в паттерне State и перечисли, за что он должен отвечать, а за что — нет. 
    Контекст — это интерфейс для клиента.

    Должен: хранить ссылку на текущее состояние, предоставлять методы для смены состояния, хранить общие данные (счётчик жвачек).

    Не должен: содержать конкретную логику поведения «что делать, если монета вставлена» — это задача объектов-состояний.

Как понять, какие фрагменты поведения нужно переносить из Контекста в состояния, а какие оставить в Контексте? 
    В состояния переносится всё, что зависит от текущей фазы работы (вариативное поведение). В контексте остается инвариантное поведение (общие утилиты, хранение данных, взаимодействие с внешним миром).

Почему в паттерне State клиент обычно не должен напрямую менять текущее состояние объекта? Какие проблемы это может вызвать? 
    Смена состояния — это внутренняя инвариантная логика автомата. Если клиент сам вызовет SetState(SoldOut), он может нарушить бизнес-правила (например, закрыть автомат, когда в нём есть деньги и товар), приведя систему в неконсистентный вид.

Объясните разницу между «объект меняет поведение» и «объект меняет класс» в терминах паттерна State. Почему говорят, что “выглядит так, будто меняет класс”? 
    Объект физически класс не меняет, но он делегирует работу другому объекту. Поскольку поведение меняется радикально (методы начинают работать совершенно иначе), для внешнего наблюдателя это выглядит так, будто сущность объекта трансформировалась в другой тип.

В примере автомата почему метод TurnCrank() вызывает и TurnCrank(), и Dispense() у состояния? Какие плюсы и минусы у такого протокола вызовов? 
    TurnCrank фиксирует намерение, а Dispense — выдачу.

    Плюсы: четкое разделение действия пользователя и реакции системы.

    Минусы: риск «забытого вызова» — если программист состояния вызовет поворот рычага, но забудет вызвать выдачу, автомат зависнет.

Какие риски появляются, если позволить состояниям напрямую менять поля Контекста (например, m_count), минуя интерфейс IGumballMachine? 
    Возникает сильная связность (tight coupling). Если формат хранения данных в контексте изменится, придется переписывать все классы состояний. Также это усложняет логирование и контроль за изменением критических данных.

Зачем вводить интерфейс IGumballMachine для состояний, если у нас уже есть класс GumballMachine? 
    Чтобы разорвать циклическую зависимость. Состояния должны знать о контексте, чтобы менять его, но знание о конкретном классе GumballMachine делает их непереносимыми и затрудняет модульное тестирование (mocking).

Почему в примере класс GumballMachine приватно наследуется от IGumballMachine? Какой архитектурный смысл в этом решении? 
    Это реализация принципа «использует для реализации». Приватное наследование скрывает служебные методы (например, ReleaseBall, SetState) от внешнего клиента, оставляя их доступными только для дружественных классов состояний.

Какие альтернативы приватному наследованию подходят для языков, где оно отсутствует (Java/C#)? Как бы вы это спроектировали? 
    Использование внутренних (inner) классов для состояний или предоставление интерфейса с доступом уровня internal/package-private. Также возможна композиция: контекст передает состояниям специальный объект-«обертку» с правами доступа.

Какие именно зависимости возникают между классами состояний, если состояния будут создавать друг друга напрямую (new HasQuarterState(...)) или ссылаться друг на друга? 
    Возникает сильная циклическая связность: класс А знает о классе Б, а Б о классе А. Это мешает их раздельной компиляции и повторному использованию.

Объясни два подхода: кто выбирает следующее состояние — Контекст или сами состояния. Когда предпочтителен каждый вариант? 
    1. Контекст: если переходы простые и линейные (упрощает состояния). 2. Состояния: если логика перехода сложная и зависит от динамических данных внутри самого состояния (делает систему гибче).

Какой вариант управления переходами лучше защищает от изменений: закрывать Контекст или закрывать состояния Обосновать через OCP. 
    Управление переходами внутри состояний лучше соответствует OCP. Чтобы добавить новый переход или состояние, мы создаем новый класс и меняем лишь соседнее состояние, не трогая стабильный код Контекста.

Как бы вы реализовали логирование/трассировку переходов между состояниями так, чтобы не нарушить SRP и не размазать std::cout по всем классам? 
    Разместить логирование в методе SetState внутри Контекста. Так как все смены состояний проходят через эту «точку входа», мы получаем централизованный аудит переходов в одном месте.

Если в системе нужно “откатить” состояние назад (undo), как это влияет на архитектуру State? Какие паттерны можно комбинировать? 
    Нужно комбинировать с паттерном Memento. Контекст должен хранить стек предыдущих объектов-состояний (или их снимков) и при команде Undo восстанавливать ссылку на предыдущее состояние.

В чём сходство диаграмм State и Strategy и почему при этом смысл у них принципиально разный? 
    Структурно они идентичны (делегирование интерфейсу). Но Strategy — это выбор «как» сделать (алгоритм задается извне один раз), а State — это «в каком режиме я сейчас», где состояния сами сменяют друг друга в процессе работы.

Приведите пример системы, где ошибочно применили Strategy вместо State (или наоборот), и объясните, какие симптомы покажут неправильный выбор. 
    Попытка реализовать «Парсер текста» через Strategy. Симптом: внутри каждой стратегии появляются гигантские if, проверяющие, какой символ был до этого, что фактически является попыткой эмулировать состояние вручную.

Какие признаки в коде указывают, что пора переходить от if/switch к паттерну State? 
    1. Наличие переменной-флага (или enum), управляющей логикой. 2. Одинаковые проверки if (state == ...) повторяются в 3 и более методах. 3. Сложно добавить новое поведение, не сломав старое.

В каких случаях паттерн State будет избыточным усложнением? Как бы вы аргументировали отказ от него? 
    Когда состояний всего два (вкл/выкл) и логика переходов тривиальна. Аргумент: паттерн State плодит классы, что неоправданно повышает сложность системы ради простой задачи («overengineering»).

Что произойдёт с тестируемостью системы после внедрения State? Какие тесты станет проще писать, а какие — сложнее? 
    Станет проще писать Unit-тесты для конкретной логики каждого состояния в изоляции. Станет сложнее писать интеграционные тесты, так как логика перехода теперь распределена между множеством мелких классов.

Как лучше организовать создание объектов состояний: (а) заранее и навсегда или (б) по требованию? Какие критерии выбора вы бы использовали? 
    (а) Заранее: если состояний мало и они легкие. (б) По требованию: если состояний много, они тяжелые по памяти или редко используются.

Почему “совместное использование объектов состояний разными контекстами” возможно только при условии, что состояния stateless? 
    Если состояние хранит данные (например, время ожидания), то при использовании двумя автоматами данные одного автомата перезапишут данные другого, вызвав хаос. Stateless-состояния ведут себя как чистые функции.

Можно ли делать состояния stateful (хранящими данные)? Когда это оправдано, и какие новые риски появляются? 
    Можно, если данные специфичны только для этой фазы (например, таймер в состоянии Processing). Риски: невозможность переиспользовать объект состояния и необходимость тщательного управления жизненным циклом (создание/удаление).

State — интерфейс или абстрактный класс? В каких случаях ты выберешь каждый вариант и почему? 
    Интерфейс — если у состояний нет общего кода. Абстрактный класс — если нужно реализовать поведение по умолчанию (например, «ничего не делать» на все события) для всех потомков, чтобы не дублировать пустые методы.

Спроектируй расширение автомата: добавь состояние “ServiceMode” (обслуживание), в котором клиент не может покупать, но техник может пополнять жвачки. Какие классы/методы появятся, какие переходы изменятся, и как сохранить чистую архитектуру? 
    1. Создать ServiceModeState. 2. Добавить метод Refill() в IState (по умолчанию пустой). 3. В Контексте добавить переход в это состояние по внешнему событию (нажатие кнопки техником). 4. Все состояния переопределяют переход в ServiceMode, а ServiceMode позволяет Refill и возврат в NoQuarterState.