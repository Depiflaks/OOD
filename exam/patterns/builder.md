Паттерн проектирования "Строитель"

Объясните назначение паттерна Builder своими словами и приведите пример ситуации, где он лучше конструктора или фабрики. 
    Паттерн предназначен для пошагового создания сложных объектов. Он лучше конструктора, когда у объекта десятки параметров (половина из которых опциональны), так как избавляет от «телескопических» конструкторов. Он лучше фабрики, когда процесс создания объекта включает сложную последовательность действий, а не просто моментальную выдачу экземпляра.

Почему Builder формулируют как «отделяет конструирование сложного объекта от его представления»? Что именно отделяется и какие проблемы это решает? 
    Отделяется алгоритм сборки (логика того, что за чем идет) от конкретной реализации шагов (логика того, как именно рисуется заголовок или вставляется картинка). Это позволяет использовать один и тот же процесс сборки для создания разных продуктов (например, PDF и HTML).

Опишите роли Director, Builder, ConcreteBuilder, Product, Client и их ответственность в терминах SRP (Single Responsibility Principle). 
    * Director (Распорядитель): отвечает за порядок (алгоритм) вызова шагов строительства.

    Builder (Строитель): определяет интерфейс для создания частей продукта.

    ConcreteBuilder: реализует конкретные шаги и хранит промежуточное состояние продукта.

    Product: итоговый сложный объект.

    Client: создает строителя, передает его распорядителю и забирает результат.

В чём разница между Builder и Abstract Factory? Приведите пример, где эти паттерны выглядят похоже, но дают разные архитектурные свойства. 
    Абстрактная фабрика возвращает объект сразу, акцентируя внимание на «семействах» объектов. Строитель создает объект по частям, акцентируя внимание на процессе. Пример: создание GUI-окна. Фабрика просто создаст кнопки и поля стиля Windows. Строитель будет пошагово добавлять элементы, настраивать их размер и вложенность.

Почему в классическом Builder распорядитель (Director) работает через абстрактный интерфейс Builder, и что это даёт с точки зрения OCP (Open/Closed Principle)? 
    Это позволяет добавлять новые форматы продуктов (новые ConcreteBuilders) без изменения логики распорядителя. Код распорядителя закрыт для модификации, но система открыта для расширения новыми типами экспорта.

Какие признаки в коде указывают, что пора внедрять Builder? 
    Конструкторы с 5+ параметрами, наличие множества методов-сеттеров, которые обязательно должны быть вызваны в определенном порядке, или наличие кода, который создает разные представления одного и того же сложного набора данных.

Можно ли применять Builder для простых объектов из 2–3 полей? Обоснуйте, когда это будет вредно. 
    Можно, но обычно вредно. Это приводит к неоправданному увеличению количества классов («взрыв сложности») и усложняет чтение кода, где достаточно обычного конструктора.

В задаче «экспорт документа в разные форматы» какие сущности логично сделать продуктами Builder, а какие — частями процесса сборки? 
    Продукты: итоговые файлы (PDF, JSON, HTML). Части процесса: BuildHeader, BuildParagraph, BuildTable, BuildImage, BuildFooter.

Спроектируйте интерфейс Builder для экспорта документа так, чтобы один и тот же процесс сборки мог создавать продукты: JSON+images, XML+images, бинарный формат. Какие методы вы бы включили и почему? 
    * AddText(string text) — для содержимого.

    AddImage(string path, bytes data) — для медиа.

    SetMetadata(string author, date) — для служебных данных.

    GetResult() — для получения готового пакета/файла. Эти методы покрывают все структурные элементы документа вне зависимости от формата.

Должен ли у продукта быть общий интерфейс или базовый класс? 
    В классическом паттерне — не обязательно. Продукты могут быть настолько разными (текстовая строка vs бинарный поток), что общего интерфейса у них может не быть вовсе.

Что означает «продукт создаётся шаг за шагом»? Приведите пример набора шагов для сборки документа в PDF или HTML. 
    Это значит, что объект не существует в готовом виде до финального вызова. Пример для HTML: 1. OpenTag("html") -> 2. AddHead(...) -> 3. OpenTag("body") -> 4. AddText(...) -> 5. CloseTags().

Как бы вы реализовали Builder для экспорта в Plain Text, чтобы он корректно обрабатывал форматирование, изображения и метаданные документа? 
    Методы форматирования (жирный/курсив) будут игнорироваться или заменяться на спецсимволы (например, *текст*). Изображения будут заменяться на текстовую ссылку или заглушку [Image: path]. Метаданные запишутся в начало файла в виде текста.

Какие инварианты и проверки корректности удобнее делать в Builder, а какие — в Director? Обоснуйте архитектурно. 
    Builder проверяет техническую корректность частей (валидность данных, формат картинки). Director проверяет логическую последовательность (нельзя добавить текст в документ, который уже закрыт/сохранен).

В каких случаях Builder должен предоставлять доступ к «частично собранному продукту»? Приведите пример из лекции и объясните, зачем это нужно. 
    Когда продукт слишком велик, чтобы хранить его в памяти целиком (например, потоковая запись огромного лог-файла или видео). Это нужно для экономии ресурсов: мы можем начать записывать части файла на диск еще до завершения всей сборки.

Почему в классической реализации Builder допускается, что методы базового Builder могут быть «пустыми» (no-op) вместо абстрактных? Какие плюсы и минусы у этого решения? 
    Плюсы: конкретным строителям не нужно реализовывать методы, которые им не важны (например, текстовый строитель игнорирует вставку видео). Минусы: клиент может не узнать, что строитель проигнорировал важную часть данных, так как нет ошибки компиляции.

Опишите, как Builder помогает «изменять внутреннее представление продукта», не меняя код Director. Приведите пример. 
    Director просто говорит: «Добавь таблицу». Если мы сменим HtmlBuilder (строит строку) на DomBuilder (строит дерево объектов), код Director останется прежним. Мы поменяли структуру данных внутри строителя, сохранив внешний интерфейс.

Что произойдёт, если Director начнёт знать конкретные классы продукта (например, PDFDocument, HtmlDocument)? Какие принципы проектирования будут нарушены? 
    Нарушится DIP (Dependency Inversion Principle) и OCP. Director станет жестко связанным с конкретными файловыми форматами, и вы не сможете добавить новый формат, не переписывая логику распорядителя.

Builder обычно создаёт один продукт за один цикл сборки. Как обеспечить возможность повторного использования одного Builder для нескольких продуктов, и какие риски это несёт? 
    Нужно реализовать метод Reset(), который очищает текущее состояние и создает новый пустой экземпляр Product. Риск: если Reset() реализован плохо, данные от старого продукта могут «протечь» в новый.

В чём отличие «классического Builder (Director + Builder)» от «Fluent Builder (цепочки вызовов)»? Когда какой вариант предпочтительнее? 
    Классический использует отдельный класс-распорядитель. Fluent использует return this; для цепочек вызовов (build().add().set()). Fluent предпочтительнее для создания внутренних DSL и библиотек, где клиент сам хочет контролировать процесс сборки.

Какие проблемы возникают, если Builder хранит слишком много состояния и становится «вторым продуктом»? Как этого избежать? 
    Возникает дублирование логики и данных. Чтобы избежать этого, нужно передавать данные в объект Product как можно раньше или использовать Product как контейнер, который Builder постепенно наполняет.

Рассмотрите сценарий: экспорт документа должен быть расширяемым (добавим EPUB через месяц). Как Builder помогает сделать это изменение минимальным? 
    Мы просто создадим новый класс EpubBuilder, реализующий интерфейс IBuilder. Код существующего документа и код Director менять не придется.

Назовите недостаток Builder из лекции и предложите 2 способа уменьшить количество классов без потери расширяемости. 
    Основной недостаток — большое количество классов. Способы: 1. Использование внутренних (inner) статических классов строителей. 2. Использование обобщенных (Generic) строителей или передача лямбда-функций в методы сборки.

Объясните, как Builder может сочетаться с паттерном Команда (Command) в архитектуре приложения. 
    Команды могут инкапсулировать вызовы методов строителя. Это позволяет реализовать Undo/Redo для процесса сборки сложного объекта или отложить процесс строительства до определенного момента.

В задаче экспорта без потери информации: как Builder должен работать с ресурсами (изображения, вложения) и ссылками на них, чтобы поддержать JSON/XML + отдельные файлы? 
    Builder должен отвечать за стратегию сохранения ресурсов: например, сохранять картинку в отдельную папку и возвращать в продукт только относительный путь или id ресурса.

Как бы вы обеспечили единый «процесс конструирования» для экспорта в HTML и PDF, если они требуют разных структур (DOM vs страницы/рендеринг)? 
    Нужно выделить абстрактные сущности верхнего уровня (Заголовок, Секция, Список), которые есть в обоих форматах. Director будет оперировать ими, а строители преобразуют их в специфичные для формата структуры.

Приведите пример ситуации, когда Director не нужен, и клиент может напрямую управлять Builder. Почему это допустимо? 
    Когда процесс сборки не является стандартным и зависит от сложного выбора пользователя в реальном времени (например, конфигуратор ПК). Это допустимо, так как клиент сам выступает в роли распорядителя.

Builder часто применяют для immutable объектов. Объясните, почему Builder хорошо сочетается с неизменяемостью и какие ошибки при этом допускают. 
    Builder накапливает изменяемое состояние, а в методе Build() создает один раз const объект. Ошибка: позволить строителю возвращать ссылку на внутренний объект, который он продолжает изменять после «выдачи» клиенту.

Как отличить Builder от Factory Method в реальном коде, если оба создают объекты? На какие признаки в API и ответственности классов вы бы смотрели? 
    У Factory Method обычно один метод (Create), который возвращает объект. У Builder — множество методов для построения частей (BuildPartA, BuildPartB) и итоговый метод GetResult.

Предложите дизайн, где один и тот же документ можно сохранить в разных форматах, не меняя код документа и минимально меняя код экспортёра. Какие паттерны вы бы использовали и почему? 
    Сочетание Visitor и Builder. Документ принимает Посетителя (который является Распорядителем), а Посетитель вызывает методы соответствующего Строителя. Это позволяет обходить структуру документа, не меняя его классы.