Паттерн проектирования "Фабричный метод" (Factory Method)

Формальное определение:

    Фабричный метод — это порождающий паттерн проектирования, который определяет интерфейс создания объекта, но позволяет подклассам принимать решение о том, экземпляр какого класса следует создать. Фабричный метод делегирует операцию создания экземпляра подклассам.


Сформулируйте идею паттерна «Фабричный метод» своими словами и объясните, где в PizzaStore он проявляется: Идея в том, чтобы перенести создание конкретных объектов из основного кода в специальный метод, который подклассы смогут переопределять. В PizzaStore он проявляется в методе createPizza(): базовый класс знает, как «заказать» пиццу (приготовить, испечь), но только конкретные региональные филиалы (NY или Chicago) знают, как «создать» свою специфическую пиццу.

Почему фабричный метод часто сочетается с шаблонным методом? Что фиксируется, а что вариативно?: Фабричный метод часто вызывается внутри Шаблонного метода. Фиксируется общий алгоритм (бизнес-логика), например, процесс обработки заказа: create() -> prepare() -> bake(). Вариативным остается само создание объекта (create()), которое делегируется подклассу.

Какие зависимости убирает фабричный метод по сравнению с прямым созданием (new/make_unique) в клиенте?: Он убирает зависимость клиента от конкретных классов продуктов. Клиент знает только об абстрактном интерфейсе продукта, что позволяет добавлять новые типы продуктов, не меняя код клиента.

Как фабричный метод помогает соблюдать OCP на примере расширения ассортимента пиццы?: Для добавления новой пиццы (например, «Веганская») вам не нужно изменять код базового PizzaStore или существующего метода заказа. Вы просто добавляете новый класс пиццы и расширяете логику в соответствующем подклассе фабрики, не затрагивая стабильный код.

В чём различие между «простая фабрика» и «фабричный метод» на уровне расширяемости и наследования?:

    Простая фабрика — это отдельный объект или статический метод. Чтобы добавить новый продукт, нужно изменять код фабрики (нарушение OCP).

    Фабричный метод использует наследование. Вы расширяете систему, создавая новые подклассы-создатели, не меняя существующие.

Опишите параметризованный фабричный метод и его типичные проблемы. Как их лечить?: Это метод, принимающий аргумент (например, string type), чтобы определить, какой объект создать. Проблемы: ошибки в строках (опечатки), раздутые конструкции switch/if. Лечение: использование Enums вместо строк, использование карт (Maps) типа «ключ-создатель» или шаблонов (templates) в C++.

Опишите непараметризованный фабричный метод. В каких сценариях он предпочтительнее?: Метод не принимает параметров и всегда создает один тип продукта, определенный подклассом. Он предпочтительнее, когда один создатель жестко связан с одним типом продукта, что делает API чище и исключает ошибки рантайма при выборе типа.

Почему «параллельные иерархии классов» считаются недостатком FactoryMethod и когда это оправдано?: Недостаток в том, что для каждого нового Product часто приходится создавать новый Creator. Это оправдано, когда логика создания продукта сложна и специфична для каждого типа, и её нельзя обобщить в одной фабрике.

Как избежать комбинаторного взрыва, если фабричных методов несколько и продуктов много?: Можно использовать шаблоны (Templates), чтобы параметризовать создателя типом продукта, или переходить к паттерну «Абстрактная фабрика», если нужно создавать целые семейства объектов.

Какие есть способы ограничить переопределение алгоритма конструирования объекта в базовом классе?: В C++ основной метод (Шаблонный метод), вызывающий фабричный, можно сделать невиртуальным (NVI), а сам фабричный метод сделать protected virtual. В других языках можно использовать ключевые слова типа final для основного метода.

Объясните, почему ошибка типа «забыли вызвать Pizza::Cut()» — системная проблема дизайна, а не баг конкретного разработчика?: Это проблема темпоральной связанности (temporal coupling). Если дизайн позволяет создать объект и «забыть» вызвать обязательный шаг подготовки, значит, ответственность распределена неверно. Базовый класс должен жестко задавать последовательность шагов в шаблонном методе.

Какая часть кода должна оставаться в базовом классе Creator, а какая — в подклассах? Назовите критерии?:

    Базовый класс: Общая бизнес-логика, не зависящая от конкретного типа продукта (алгоритм работы с продуктом).

    Подклассы: Исключительно инстанцирование (вызов new или make_unique) конкретного продукта.

Как фабричный метод соотносится с DIP: кто от кого должен зависеть?: И создатель (высокоуровневый модуль), и конкретные продукты (низкоуровневые модули) должны зависеть от абстрактного интерфейса продукта. Это инвертирует зависимость: теперь не магазин зависит от пиццы, а всё зависит от абстракции «Пицца».

Почему использование строковых параметров (type == "cheese") — риск? Предложите улучшение API?: Риски: опечатки не ловятся компилятором, нет автодополнения в IDE. Улучшение: использовать enum class, константы или передавать типы через шаблоны createPizza<CheesePizza>().

Какие варианты обработки ошибок создания продукта вы предложите (исключения/Optional/Result) и как это влияет на дизайн Creator?:

    Исключения: Хороши, если создание продукта критично.

    std::optional / nullptr: Подходят для ситуаций, когда «продукт не найден» — нормальный сценарий.

    std::expected / Result: Позволяют вернуть причину ошибки. Это усложняет сигнатуру метода в Creator, заставляя клиента обрабатывать ошибку.

Как тестировать базовый алгоритм Creator независимо от конкретных продуктов?: Нужно создать «Тестовый продукт» (Mock) и «Тестового создателя», который его возвращает. Затем проверить, что базовый алгоритм Creator корректно вызывает методы этого Mock-продукта.

Как тестировать конкретный подкласс Creator так, чтобы не дублировать тесты базового алгоритма?: Достаточно протестировать только факт того, что метод возвращает объект правильного типа. Тестировать весь алгоритм работы с ним в подклассе не нужно — это зона ответственности тестов базового класса.

Когда FM превращается в анти-паттерн: «переабстракция на вырост»? Приведите признаки?: Когда в системе всего один тип продукта и один создатель, и в ближайшее время расширение не планируется. Признаки: избыток интерфейсов, которые имеют ровно одну реализацию, и сложность чтения кода из-за постоянных прыжков по иерархии.

Как выглядит «протекающая абстракция» в FM и как её исправить (когда клиент всё равно знает ConcreteProduct)?: Это ситуация, когда клиент вынужден делать dynamic_cast результата фабричного метода к конкретному классу, чтобы вызвать специфический метод. Исправление: расширить базовый интерфейс продукта или использовать паттерн «Посетитель» (Visitor).

В чём смысл требования: «Creator не должен делать предположений о конкретном типе продукта»? Как это нарушается на практике?: Смысл в полной независимости алгоритма от реализации. На практике нарушается, когда в базовом классе пишут код типа if (dynamic_cast<NYPizza*>(pizza)) { ... }.

Как бы вы рефакторили код DependentPizzaStore, чтобы применить фабричный метод и уменьшить зависимости?: Нужно выделить метод createPizza() как абстрактный, превратить DependentPizzaStore в абстрактный класс (или интерфейс), а логику создания конкретных пицц разнести по подклассам NYPizzaStore и ChicagoPizzaStore.

Что изменится в проекте при добавлении новой пиццы и нового региона при использовании FM? Сравните с подходом без FM?:

    Без FM: Придется менять гигантский if-else в одном общем классе, что рискованно и нарушает OCP.

    С FM: Нужно просто добавить новый класс пиццы и новый класс магазина. Старый код не трогается, риск регрессии минимален.

Как выбрать между FM и Strategy для задачи «выбор типа создаваемого объекта во время выполнения»?:

    FM: Если фокус на создании объекта и управлении его жизненным циклом через иерархию.

    Strategy: Если вам нужно менять логику (алгоритм) уже созданного объекта. Часто FM используется для создания объекта, который затем вставляется в Контекст как Стратегия.

Какие компромиссы возникают при попытке сделать фабричный метод статическим?: Статический метод нельзя переопределить в подклассах. Это убивает саму суть Фабричного метода, превращая его в «Простую фабрику». Мы теряем полиморфизм при создании.

Как фабричный метод влияет на способность кэшировать/переиспользовать продукты или их части?: FM позволяет реализовать логику кэширования (например, паттерн Flyweight) внутри конкретного создателя. Клиент вызывает create(), а создатель решает: вернуть новый объект или взять его из пула.

В C++: какие вопросы владения ресурсами (unique_ptr/shared_ptr) особенно важны при реализации FM?: Важно возвращать std::unique_ptr по умолчанию, так как он легко конвертируется в shared_ptr, если клиенту нужно совместное владение, но при этом четко заявляет о передаче прав собственности на объект.

Как обеспечить, что разные подклассы Creator не нарушат инварианты продукта (например, обязательные шаги подготовки)?: Использовать NVI (Non-Virtual Interface): публичный финальный метод в базе вызывает prepare(), затем create() (виртуальный), затем bake(). Подкласс может менять только create(), не имея возможности пропустить prepare() или bake().

Приведите пример, где FM лучше заменить на Abstract Factory, и объясните, почему FM не справляется?: Пример: создание интерфейса для разных ОС (кнопки, чекбоксы, меню). FM справится с созданием кнопки, но он не гарантирует, что если вы создали Windows-кнопку, то и чекбокс будет Windows-стиля. FM создает один объект, а Abstract Factory — семейство взаимосвязанных объектов.