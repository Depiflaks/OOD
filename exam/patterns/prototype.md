Паттерн проектирования "Прототип"

В чём состоит основная идея паттерна Prototype и какую проблему создания объектов он решает? 
    Основная идея заключается в создании новых объектов путём копирования уже существующего экземпляра-эталона (прототипа). Он решает проблему зависимости клиента от конкретных классов при создании объектов и позволяет избежать сложной инициализации «с нуля», если состояние объекта уже настроено.

Почему подход «создать пустой объект и скопировать поля по очереди» часто не работает в ООП? Приведите минимум 2 причины. 
    1. Нарушение инкапсуляции: многие важные поля могут быть приватными и недоступными для внешнего копирования. 2. Неизвестность типа: клиент может работать с объектом через интерфейс и не знать его реального класса, чтобы вызвать new и получить доступ к специфичным полям.

Как Prototype помогает клиенту создавать объекты, не зная их конкретных типов? 
    Клиент вызывает полиморфный метод (например, Clone()) через базовый интерфейс. Ответственность за создание копии перекладывается на сам объект, который точно знает свой тип и может создать своего «двойника».

В каких ситуациях Prototype предпочтительнее, чем прямой вызов конструктора? Приведите примеры. 
    Когда стоимость создания объекта велика (например, загрузка из БД или сложный расчёт) или когда нужно клонировать объект, чьё текущее состояние (runtime state) важнее, чем его начальные настройки. Примеры: Клонирование сложной фигуры в графическом редакторе; создание игровых юнитов с уже применёнными модификаторами.

В каких ситуациях Prototype предпочтительнее, чем фабричный метод/абстрактная фабрика, и почему? 
    Когда количество вариаций объектов велико и их создание через фабрики привело бы к «взрыву» иерархии классов. Прототип позволяет просто хранить набор преднастроенных объектов в реестре, не создавая под каждый вариант отдельный класс фабрики.

Что означает «классы определяются во время выполнения» в контексте Prototype? Как это влияет на архитектуру? 
    Это значит, что мы можем добавлять «новые типы» объектов в систему, просто регистрируя их экземпляры в реестре прототипов без перекомпиляции кода. Архитектура становится более гибкой и динамичной, так как логика создания заменяется логикой копирования.

Чем отличается «поверхностное» (shallow) клонирование от «глубокого» (deep)? Когда нужно каждое из них? 
    * Поверхностное: копирует только значения полей и адреса указателей. Нужно, когда ресурсы могут быть разделяемыми (immutable объекты).

    Глубокое: рекурсивно копирует все объекты, на которые ссылается оригинал. Нужно для полной независимости копии от оригинала (mutable ресурсы, массивы).

Какие типовые сложности возникают при глубоком клонировании графа объектов с циклическими ссылками? Как их решать? 
    Возникает риск бесконечной рекурсии и дублирования объектов. Решение: использование вспомогательного словаря (Map), где ключом является адрес оригинального объекта, а значением — адрес его уже созданной копии.

Какие инварианты класса могут быть нарушены при некорректной реализации Clone()? Приведите примеры инвариантов. 
    Могут быть нарушены правила владения ресурсами или уникальности. Примеры: Двойное освобождение памяти (если два объекта владеют одним указателем); нарушение уникальности ID (если копия получила тот же ID, что и оригинал).

Почему важно, чтобы у базового интерфейса прототипа был виртуальный деструктор? 
    Чтобы при удалении клонированного объекта через указатель на базовый класс правильно вызывались деструкторы всех производных классов, предотвращая утечки памяти.

Почему сигнатура unique_ptr<Base> Clone() const чаще удачнее, чем возврат сырого указателя? Какие риски она снимает? 
    Она явно передаёт владение вызывающему коду и гарантирует автоматическое освобождение памяти. Это снимает риск утечки памяти, если клиент забудет вызвать delete, и делает код исключениебезопасным.

Какие требования накладывает реализация Clone() через копирующий конструктор на тип Impl? 
    Тип Impl должен иметь доступный и корректно реализованный копирующий конструктор, который выполняет необходимое глубокое или поверхностное копирование.

В чём состоит дублирование кода в «наивной» реализации Clone() в каждом подклассе и как CRTP помогает его убрать? 
    В каждом классе приходится писать идентичный код: return std::make_unique<CurrentClass>(*this);. CRTP позволяет вынести эту логику в шаблонный базовый класс, который автоматически генерирует Clone() для конкретного типа-наследника.

*Объясните идею CRTP в PrototypeImpl<Impl, Interface>. Почему внутри Clone делается static_cast<const Impl>(this)? Ответ:** Идея в том, что базовый класс «знает» тип своего наследника через параметр шаблона. static_cast нужен, чтобы вызвать копирующий конструктор именно конкретного класса Impl, а не интерфейса.

Какие риски появляются из-за static_cast в CRTP-реализации, и как их минимизировать? 
    Риск ошибочного указания типа в шаблоне (например, class B : public PrototypeImpl<A, I>). Минимизация: использовать static_assert для проверки иерархии или сделать конструкторы Impl приватными, разрешив доступ только PrototypeImpl.

Как влияет отсутствие конструктора по умолчанию у базового класса на проектирование PrototypeImpl? Зачем нужен using Base::Base? 
    Если у базы нет дефолтного конструктора, PrototypeImpl не сможет инициализироваться. using Base::Base позволяет «пробросить» конструкторы базового класса в наследник, чтобы PrototypeImpl мог принимать те же аргументы.

Какие архитектурные плюсы даёт использование реестра прототипов (Prototype Registry) по сравнению с фабрикой? 
    Реестр позволяет динамически изменять набор доступных объектов (добавлять/удалять прототипы) во время выполнения, тогда как фабрика обычно жёстко зашита в код.

Разберите пример ShapeGroup: какие требования к клонированию элементов группы и почему там нужен кастомный copy-конструктор? 
    Группа должна выполнить глубокое клонирование всех своих дочерних фигур. Кастомный конструктор нужен, чтобы создать новые экземпляры фигур, а не просто скопировать указатели на старые, иначе изменение в группе-копии испортит оригинал.

Почему наследование Worker от конкретного Person (в примере со слайда) является “красным флагом”? Назовите минимум 3 причины. 
    1. Нарушение LSP (Liskov Substitution Principle). 2. Сильная связность (Tight Coupling) с деталями реализации. 3. Хрупкость базового класса (изменение Person может сломать специфику Worker).

Как в этом примере может быть нарушен LSP? Сформулируйте возможные пред/постусловия у Person::SpendDay() и как их нарушит Worker. 
    Предусловие: Person может проводить день как угодно. Нарушение: Worker может требовать наличия рабочего места или определённого времени суток (только в будни), что сужает контракт базового класса и ломает логику клиента, ожидающего обычного человека.

Что такое Fragile Base Class Problem и как он проявляется в иерархии Person → Worker при эволюции кода? 
    Это проблема, когда небольшие изменения в базе (Person) ломают работу наследников (Worker). Например, добавление нового поля в Person, которое требует инициализации, может быть не учтено в Worker, что приведёт к неопределённому поведению.

Что означает “Refused Bequest” (отвергнутое наследство) и как оно может привести к лишним полям и ухудшению производительности? 
    Это ситуация, когда наследник использует лишь малую часть функционала базы. В итоге Worker тащит за собой все поля и методы Person (например, "хобби", "список друзей"), которые ему не нужны, увеличивая расход памяти и сложность объекта.

Какие подходы исправления проблем наследования от конкретного класса вы бы выбрали в разных сценариях: NVI/Template Method, композиция, стратегия, mixin? Обоснуйте. 
    * Композиция: если Worker — это роль человека (лучший выбор для гибкости).

    Стратегия: если нужно менять поведение «работы» на лету.

    NVI: если нужно гарантировать выполнение базовой логики перед/после действий наследника.

Зачем в варианте с PersonImpl<Base> метод GetName() делают final? Какие компромиссы и альтернативы есть? 
    Чтобы гарантировать единообразную реализацию и запретить наследникам ломать контракт получения имени. Альтернатива: сделать поле m_name защищённым, но это ослабляет инкапсуляцию.

Какие риски у решения через mixin-ы и шаблонное наследование? Как их контролировать? 
    Риски: чрезмерная сложность сигнатур (template soup) и трудность отладки. Контроль: использование static_assert, концептов (C++20) и строгая документация иерархии.

Какие проверки стоит добавить в PrototypeImpl с помощью C++20 Concepts/static_assert, и какие ошибки они позволяют ловить раньше? 
    Проверку std::is_copy_constructible_v<Impl> и std::is_base_of_v<Interface, Impl>. Это позволяет поймать попытку создать прототип от класса, который нельзя копировать, или который не реализует нужный интерфейс на этапе компиляции.

Почему std::any не поддерживает «восходящее» приведение к базовому типу (any_cast<IShape&> при хранении Circle), и как это влияет на дизайн type-erasure? 
    std::any хранит тип «как есть» и не знает об иерархии наследования. Это заставляет проектировать собственные обёртки для Type Erasure, которые хранят не просто объект, а виртуальную таблицу (vtable) или набор функциональных указателей для нужного интерфейса.

Сравните два подхода “классический полиморфизм через unique_ptr<IShape>” и “type erasure через std::any” с точки зрения: производительности (конструирование vs вызовы), владения, локальности данных, расширяемости и сложности реализации. Ответ: