Дайте определение паттерна «Компоновщик» и объясните, какую проблему проектирования он решает на практике. 
    Это структурный паттерн проектирования, который позволяет сгруппировать объекты в древовидную структуру и работать с этой структурой так, будто это единичный объект. Он решает проблему неоднородности: клиенту не нужно проверять, работает ли он с простым объектом или с группой объектов, что упрощает код и уменьшает количество условных операторов.

В чём состоит ключевая идея «прозрачности» (transparency) в Composite и почему она важна для клиентского кода? 
    Ключевая идея в том, что интерфейс базового компонента содержит методы для управления дочерними элементами. Это позволяет клиенту единообразно обращаться ко всем узлам дерева. Прозрачность важна, так как она делает клиентский код независимым от конкретных классов (листьев или групп), позволяя добавлять новые типы элементов без изменения логики обхода или отрисовки.

Объясните роли Component / Leaf / Composite и приведите пример соответствия этим ролям в задаче «слайд–фигуры–группы». 
    * Component (Компонент): Общий интерфейс для всех элементов. В примере — это IShape.

    Leaf (Лист): Простой элемент, не имеющий детей. В примере — Rectangle, Triangle, Ellipse.

    Composite (Компоновщик): Контейнер, содержащий дочерние компоненты. В примере — GroupShape.

Почему древовидная структура естественна для моделирования отношений «часть–целое»? Приведите 2–3 примера из реальных систем. 
    Дерево позволяет выразить рекурсивную вложенность, где целое состоит из частей, которые сами могут быть «целыми» для других частей. Примеры:

    Файловая система: папки содержат файлы и другие папки.

    GUI (Графический интерфейс): окно содержит панели, которые содержат кнопки и текстовые поля.

    DOM в HTML: тег <div> может содержать текст и другие теги.

Какие инварианты должны выполняться в корректной реализации Composite-дерева? 
    1. Отсутствие циклов: объект не может быть своим собственным предком. 2. Единственность родителя: (обычно) каждый узел имеет не более одного родителя. 3. Целостность связей: если узел A считает узел B своим ребенком, то узел B должен считать узел A своим родителем (если ссылки на родителей реализованы).

Опишите, как будет выглядеть интерфейс IDrawable/IShape, чтобы и листья, и группы можно было рисовать одинаково. Какие операции туда логично включать? 
    Интерфейс должен содержать методы:

    Draw(ICanvas& canvas) — отрисовка.

    GetFrame() / SetFrame() — получение и изменение ограничивающей рамки.

    GetOutlineStyle() / SetOutlineStyle() — управление контуром.

    GetFillStyle() / SetFillStyle() — управление заливкой.

Что произойдёт архитектурно, если добавить группировку фигур “в лоб”, без Composite? Какие проблемы возникнут? 
    Возникнет нарушение принципа открытости/закрытости (OCP). Клиентскому коду придется постоянно проверять тип объекта (if (isGroup)), что приведет к дублированию кода обработки списков и сделает систему хрупкой при добавлении новых видов контейнеров или фигур.

В примере со слайдами: почему удобно, что Slide тоже реализует IDrawable? Как это влияет на дизайн? 
    Это позволяет рассматривать слайд как высокоуровневый компонент. Дизайн становится унифицированным: мы можем отрисовать весь слайд одним вызовом Draw, или даже вложить один слайд в другой (например, для режима предпросмотра "сетка слайдов"), не меняя логику отрисовщика.

Как вы реализуете GroupShape::Draw(canvas) так, чтобы поведение соответствовало «группа ведёт себя как одна фигура»? 
    Метод Draw в GroupShape должен просто итерироваться по всем своим дочерним элементам и вызывать у каждого их собственный метод Draw. Таким образом, вызов одной команды для группы инициирует отрисовку всех входящих в неё элементов.

Опишите корректную реализацию GetFrame() для группы фигур: какие случаи нужно учесть и почему пустая группа — отдельная проблема? 
    GetFrame группы — это минимальный прямоугольник, включающий в себя GetFrame всех детей (логическое объединение).

    Случаи: нужно вычислить min(left), min(top), max(right), max(bottom).

    Проблема пустой группы: у неё нет детей, поэтому её границы неопределены (можно возвращать нулевой прямоугольник или optional, иначе логика объединения сломается на начальных значениях координат).

Как реализовать SetFrame() для группы так, чтобы изменения размеров/положения группы пропорционально изменяли детей? Какие ошибки и трудности возможны? 
    Нужно вычислить коэффициент масштабирования и смещение. Для каждого ребенка новое положение рассчитывается как: new_child_rect=scale×(old_child_rect−old_group_rect)+new_group_rect.

    Трудности: деление на ноль при попытке изменить размер группы с нулевой шириной/высотой, накопление ошибок округления при многократных трансформациях (floating point errors).

Что такое Z-order и как порядок потомков в Composite влияет на отрисовку и пользовательские ожидания? 
    Z-order — это порядок перекрытия объектов по «глубине» экрана. В Composite порядок детей в списке определяет Z-order: объекты, отрисованные позже, перекрывают те, что были отрисованы раньше. Пользователь ожидает, что элементы внутри группы сохраняют свой относительный порядок при перемещении всей группы.

Какие варианты хранения детей вы бы выбрали в C++: unique_ptr, shared_ptr, ссылки/сырой указатель? Обоснуйте выбор для фигур/групп. 
    Лучшим выбором будет std::shared_ptr или std::unique_ptr.

    unique_ptr — если фигура принадлежит строго одной группе (строгая композиция).

    shared_ptr — если мы планируем использовать Undo/Redo системы или передавать владение между слайдами и буфером обмена без немедленного удаления. Сырые указатели опасны утечками памяти.

Объясните разницу между композицией и агрегацией в контексте групп фигур и приведите пример, когда нужна агрегация. 
    * Композиция: группа владеет фигурами, при удалении группы удаляются фигуры.

    Агрегация: группа лишь ссылается на фигуры, существующие независимо. Агрегация нужна, например, в «Виртуальных группах» или «Selection», когда мы временно объединяем объекты для трансформации, но они должны остаться на своих местах в основной структуре после снятия выделения.

Зачем может понадобиться ссылка на родителя в узлах Composite? Какие операции она упрощает? 
    Ссылка на родителя упрощает обход дерева снизу вверх. Это нужно для:

    Вычисления глобальных координат (сумма смещений всех предков).

    Уведомления об изменениях (инвалидация кэша родителя).

    Удаления объекта (объект сам просит родителя удалить его из списка детей).

Какие риски возникают при хранении ссылок на родителей? Как обеспечить инвариант «если A.parent = B, то B содержит A»? 
    Риск — циклические зависимости, которые в случае shared_ptr приведут к утечкам (нужно использовать weak_ptr для родителя). Инвариант обеспечивается инкапсуляцией: методы Add/Remove внутри себя должны атомарно менять и список детей у родителя, и поле parent у ребенка.

Можно ли разрешить совместное использование компонентов (один дочерний объект у двух родителей)? Какие проблемы это создаёт для определения родителя, удаления и трансформаций? 
    Да, это превращает структуру из дерева в направленный ациклический граф (DAG).

    Проблемы: GetParent() становится неоднозначным (нужен список родителей); удаление одного родителя не должно удалять объект; трансформации через одного родителя могут неожиданно изменить вид объекта в другом родителе.

Объясните дилемму: где размещать операции Add/Remove/GetChild — в Component или только в Composite? Какие плюсы/минусы у каждого варианта? 
    * В Component (Прозрачность): Плюс — единообразие, клиент не делает downcast. Минус — нарушение безопасности (у Листа эти методы не имеют смысла и могут упасть с ошибкой).

    В Composite (Безопасность): Плюс — Лист не имеет лишних методов. Минус — клиенту нужно постоянно проверять тип объекта, прежде чем вызвать Add.

Опишите компромисс через GetComposite() (возвращает nullptr для листьев). В чём частичная потеря прозрачности и как клиент должен действовать? 
    Этот метод позволяет безопасно узнать, является ли объект контейнером. Потеря прозрачности в том, что клиент всё равно пишет if (auto composite = item->GetComposite()). Однако это чище, чем dynamic_cast, так как тип проверяется через интерфейс.

Как лучше реализовать “неразумные” операции для листьев (например, Add у Leaf): пустая реализация, исключение, код ошибки? Обоснуйте. 
    Рекомендуется бросать исключение (std::logic_error), так как вызов Add у Листа — это программная ошибка в логике клиента. Пустая реализация ("silent fail") опасна, так как клиент может думать, что объект добавлен, хотя это не так.

Какие типичные логические ошибки возможны при построении структуры Composite и как их предотвращать? 
    1. Создание циклов: предотвращать проверкой при добавлении. 2. Двойное добавление: один объект дважды в одной группе. Предотвращать проверкой наличия в списке. 3. Потеря узлов: некорректное удаление без очистки ссылок. Использовать умные указатели.

Как бы вы реализовали проверку на циклы при Add? Какие компромиссы по производительности и удобству появляются? 
    При добавлении ребенка C в родителя P, нужно пройтись от P вверх по цепочке родителей. Если мы встретим C, значит возникнет цикл.

    Компромисс: O(N) на операцию добавления (где N — глубина дерева). Для очень глубоких деревьев это может быть заметно, но обычно структура плоская и проверка мгновенна.

Зачем Composite может кешировать вычисления (например, bounding box группы)? Как организовать инвалидирование кэша при изменении детей? 
    Пересчет границ группы при каждом обращении (особенно при отрисовке 60 FPS) затратен, если в группе тысячи элементов.

    Инвалидация: при изменении состояния Листа (например, SetFrame), он вызывает parent->InvalidateCache(), который сбрасывает свой кэш и рекурсивно уведомляет своего родителя вверх до корня.

Опишите схему уведомлений “child changed → parent invalidates cache → уведомляет своего parent”. Какие варианты реализации? 
    1. Прямой вызов: через ссылку на родителя. 2. Паттерн Observer: родители подписываются на события детей. Прямой вызов эффективнее по памяти и скорости для древовидных структур.

Почему часто Composite сочетают с Visitor? Приведите пример операции, которую лучше вынести в Visitor, а не добавлять в классы фигур/узлов. 
    Чтобы не раздувать интерфейс Component новыми методами при каждой новой задаче.

    Пример: Сериализация в JSON или экспорт в SVG. Если добавлять это в классы фигур, код классов станет перегруженным. Visitor позволяет вынести эту логику во внешний класс.

Объясните связь Composite и Iterator: какие задачи решает внешний итератор по дереву, и почему это лучше, чем “ручная рекурсия” в клиентском коде? 
    Итератор скрывает сложность обхода (стек, рекурсию) внутри себя. Это лучше ручной рекурсии, так как клиент может прервать обход в любой момент, использовать стандартные алгоритмы (например, std::find_if) и не заботиться о деталях реализации структуры дерева.

Как реализовать обход дерева: DFS/BFS, “только листья”, “только видимые” — и где в дизайне лучше задавать стратегию обхода? 
    Обход обычно реализуется через внешний класс-итератор.

    DFS (в глубину) стандартен для отрисовки.

    Стратегию лучше задавать, передавая конкретный тип итератора или используя фабричный метод у Composite. Это позволяет менять логику обхода, не меняя структуру данных.

Можно ли реализовать Composite без наследования через std::variant/std::visit? Какие преимущества и ограничения такого подхода по сравнению с виртуальными методами? 
    Да, можно использовать std::vector<std::variant<Rectangle, Triangle, Group>>.

    Плюсы: отсутствие виртуальных вызовов (быстрее), данные лежат в памяти компактнее.

    Ограничения: фиксированный набор типов (нужно перекомпилировать код при добавлении новой фигуры), усложняется рекурсивное определение (нужен recursive_wrapper).

Опишите функциональный вариант “Компоновщика” для команд: простые функции + макро-функция, работающая с контекстом (мутабельным или иммутабельным). Какие плюсы/минусы и где это применимо? 
    Каждая команда — это функция Context -> Context. Макро-команда — это функция, которая последовательно применяет список функций.

    Плюсы: предельная простота, отсутствие иерархии классов.

    Минусы: сложность реализации отката (Undo) или доступа к метаданным отдельных шагов внутри макро-команды. Применимо в обработке сигналов или функциональных UI-фреймворках.