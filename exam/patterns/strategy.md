Основы проектирования

- В чём принципиальная разница между умением писать код и умением проектировать систему? 
    Написание кода — это реализация конкретных алгоритмов и функций (решение задачи «здесь и сейчас»). Проектирование — это определение структуры, связей и границ компонентов для обеспечения гибкости, масштабируемости и простоты поддержки в будущем.

- Почему требования к программным системам почти всегда изменяются, и как это влияет на выбор архитектуры? 
    Бизнес-среда динамична: меняются законы, нужды пользователей и технологии. Архитектура должна быть «эластичной», чтобы изменения в одной части системы не вызывали каскадного разрушения (регрессии) в других.

- Почему паттерны проектирования не являются «готовыми решениями»?
    Паттерн — это не библиотека, а архитектурный шаблон (концепция). Его нужно адаптировать под конкретный контекст, язык программирования и ограничения системы.

- Как паттерн «Стратегия» помогает избежать «велосипедостроения»?
    Он предлагает проверенный стандарт разделения ответственности: вместо изобретения сложных иерархий наследования или громоздких if-else, мы используем композицию и интерфейсы.

- В каких ситуациях применение паттерна «Стратегия» может быть избыточным или вредным? Приведите пример. 
    Когда вариантов поведения всего 1-2 и они гарантированно не будут меняться. Пример: расчет налогов для приложения, работающего строго в одной стране с фиксированной ставкой. Лишние классы только усложнят код (Overengineering).

Анализ примера с утками (Duck Simulator)

- Какие архитектурные проблемы проявились в начальной реализации «утиного симулятора» при добавлении Fly()? 
    Наследование привело к тому, что неподходящее поведение (полет) получили классы, которым оно не нужно (резиновые утки). Код стал жестким и некорректным.

- Почему «локальное изменение кода привело к нелокальным эффектам» — особенно опасная ситуация в командной разработке? 
    Изменение в базовом классе незаметно ломает логику в десятках наследников. В команде это приводит к тому, что один разработчик случайно портит работу других, что подрывает стабильность системы.

- Почему переопределение Fly() и Quack() в подклассах плохо масштабируется? 
    Это ведет к дублированию кода: если 10 видов уток летают одинаково, придется копировать один и тот же код в 10 классов.

- Какие проблемы в примере с утками относятся к нарушению SRP, а какие — к нарушению OCP?
    - SRP: Класс Duck отвечает и за общие свойства утки, и за детали реализации всех видов полета/кряканья.
    - OCP: Чтобы добавить новый способ полета, приходится изменять существующий код классов вместо расширения.

- Что такое «хрупкий базовый класс» и почему это фундаментальная проблема ООП? 
    Это ситуация, когда малейшее изменение в базовом классе приводит к поломке наследников из-за их жесткой зависимости от реализации предка. Это нарушает инкапсуляцию.

- Почему решение с интерфейсами Flyable / Quackable и dynamic_cast считается архитектурно слабым?
    Интерфейсы в чистом виде не позволяют переиспользовать код (в каждом классе нужно писать реализацию заново), а dynamic_cast — это признак плохого дизайна, нарушающий абстракцию и снижающий производительность.

Принципы и структура паттерна

- По каким признакам в существующем коде можно понять, что пора заменить наследование композицией? 
    Когда вы замечаете дублирование кода в разных ветках наследования или когда подклассы начинают «отказываться» от методов предка (оставляя их пустыми или выбрасывая исключения).

- Почему принцип «отделяйте изменяемое от неизменяемого» является ключевым для стратегии? 
    Это позволяет изолировать части кода, которые часто меняются, чтобы их модификация не затрагивала стабильный каркас системы.

- Как независимость изменений полёта и кряканья влияет на структуру классов? 
    Это позволяет вынести их в отдельные иерархии интерфейсов. Теперь мы можем менять алгоритм полета, не трогая алгоритм звука.

- Как принцип Program to an interface, not an implementation реально снижает стоимость изменений? 
    Контекст (Утка) ничего не знает о конкретном классе полета. Это позволяет добавлять новые способы полета, не меняя ни одной строчки в классе Duck.

- Дайте развёрнутое определение паттерна «Стратегия» и опишите роли Контекста и Стратегии. 
    Стратегия — это паттерн, который определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

    - Контекст: содержит ссылку на стратегию и делегирует ей выполнение работы.
    - Стратегия: общий интерфейс для всех алгоритмов.
    Shutterstock

- Почему делегирование поведения снижает связанность системы? 
    Контекст и конкретный алгоритм связаны только через узкий интерфейс. Они могут развиваться и тестироваться независимо друг от друга.

Продвинутые вопросы и детали реализации

- Какие преимущества и риски даёт динамическая смена стратегии в рантайме?
    - Преимущества: гибкость (утка может «на лету» сменить крылья на ракетный двигатель).
    - Риски: сложность отладки и возможность перехода системы в несогласованное состояние, если стратегия сменится в середине процесса.

- В каких случаях Контекст стоит делать интерфейсом, а в каких — конкретным классом?
    - Интерфейс: если нам нужно несколько разных типов Контекстов, использующих одни и те же стратегии.
    - Класс: если Контекст — это стабильная сущность с общим состоянием (как базовый класс Duck).

- Почему возможность переиспользования стратегий другими объектами — признак хорошей абстракции? 
    Это означает, что алгоритм выделен чисто и не зависит от конкретного окружения. Например, стратегия «Полет с крыльями» может подойти и утке, и самолетику.

- Могут ли стратегии иметь собственное состояние? 
    Да, стратегии могут хранить данные, необходимые для работы алгоритма (например, количество оставшегося топлива для полета).

- Когда наличие состояния в стратегии — оправданное решение, а когда — симптом вырождающейся архитектуры? 
    Оправдано, если состояние относится только к алгоритму. Плохо, если стратегия начинает хранить данные, принадлежащие Контексту, или пытаться управлять жизненным циклом Контекста.

- В чём разница между хранением состояния в Контексте и в Стратегии? 
    В Контексте хранится состояние «объекта» (имя, возраст), в Стратегии — состояние «процесса» (текущая скорость, накопленная ошибка в ПИД-регуляторе).

- Почему попытка «хранить всё состояние в Контексте» может привести к плохому дизайну? 
    Это превращает Контекст в "God Object", а интерфейс стратегии становится перегруженным из-за необходимости передавать туда слишком много параметров.

- Как принципы YAGNI и KISS влияют на решение о добавлении состояния в стратегию? 
    Если текущая задача не требует состояния, лучше сделать стратегию stateless (без состояния). Это упростит тестирование и позволит использовать один экземпляр стратегии для многих объектов (паттерн Flyweight).

Технические аспекты (C++)

- Что означает const-метод в интерфейсе стратегии с точки зрения контракта? 
    Это гарантия того, что вызов алгоритма не изменит внутреннее состояние самой стратегии. Это важно для потокобезопасности и предсказуемости.

- Почему опасно объявлять командные методы стратегии const, даже если реализация «умеет» это обойти? 
    Использование mutable или const_cast внутри стратегии скрывает побочные эффекты. Это вводит в заблуждение пользователя интерфейса и может привести к трудноуловимым багам при многопоточности.

- Как LSP и CQS ограничивают проектирование интерфейсов стратегий в C++?
    - LSP: любая конкретная стратегия должна корректно работать везде, где ожидается интерфейс (не бросать неожиданных исключений).
    - CQS: метод стратегии должен либо возвращать результат (запрос), либо изменять состояние (команда), но не то и другое сразу, чтобы интерфейс оставался ясным.

- В каких случаях допустима логическая константность (mutable), и какие архитектурные риски она несёт? 
    Допустима для кэширования результатов или логирования. Риск: нарушение потокобезопасности, если объект стратегии используется несколькими контекстами одновременно.

- Кто должен определять интерфейс стратегии — разработчик Контекста или разработчик стратегий? Почему? 
    Разработчик Контекста. Согласно принципу инверсии зависимостей (DIP), высокоуровневый модуль (Контекст) диктует контракт, который ему необходим для работы.