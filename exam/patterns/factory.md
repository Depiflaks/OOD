Паттерн проектирования "Абстрактная фабрика" (Abstract Factory)

Формальное определение:

    Абстрактная фабрика — это порождающий паттерн проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

Ответы на вопросы по паттерну "Абстрактная фабрика"

Объясните, какую проблему «Абстрактная фабрика» решает лучше, чем «простая фабрика» и «фабричный метод»: Абстрактная фабрика решает проблему согласованности (консистентности) продуктов. В то время как «простая фабрика» или «фабричный метод» создают один объект из одной иерархии, абстрактная фабрика гарантирует, что все созданные объекты (например, кресло, диван и стол) принадлежат к одному семейству (например, стилю «Модерн»), исключая их несовместимость.

Что именно скрывает от клиента абстрактная фабрика кроме конкретных классов продуктов?: Она скрывает детали процесса создания, логику выбора конкретных типов продуктов для конкретного семейства и знание о том, какие продукты вообще «умеют» работать друг с другом. Клиент видит только высокоуровневый интерфейс создания.

Как «Абстрактная фабрика» помогает соблюдать DIP? Опишите зависимости «до» и «после»:

    До: Клиент напрямую зависит от конкретных классов продуктов (new WoodChair(), new WoodTable()).

    После: Клиент зависит только от интерфейса фабрики (IFurnitureFactory) и интерфейсов продуктов (IChair, ITable). Высокоуровневая логика больше не зависит от деталей реализации низкоуровневых компонентов.

Что считается «семейством продуктов» и почему важно создавать их согласованно?: Семейство — это набор объектов, предназначенных для совместной работы или имеющих общую черту (платформа, стиль, регион). Согласованность важна для предотвращения ошибок: например, нельзя пытаться отрисовать кнопку в стиле Windows на окне в стиле macOS, так как это приведет к визуальным или системным конфликтам.

В каких случаях абстрактная фабрика превращается в God Factory и как это распознать по симптомам в коде?: Это происходит, когда в одну фабрику пытаются добавить создание абсолютно всех объектов системы. Симптомы: интерфейс фабрики содержит десятки методов Create..., которые логически не связаны между собой; при добавлении любого нового класса в проект приходится править интерфейс фабрики.

Опишите стратегию тестирования кода, который использует абстрактную фабрику: что мокается и что проверяется?: Мокается интерфейс самой фабрики (IAbstractFactory). Проверяется, что клиент вызывает именно те методы фабрики, которые нужны для его задачи, и корректно обрабатывает возвращаемые абстрактные интерфейсы продуктов.

Почему «неполные семейства» (часть create не реализована) — архитектурная проблема? Какие варианты дизайна решают её?:* Это нарушает ожидания клиента и принцип LSP (подстановка Лисков), так как клиент рассчитывает получить объект, а получает ошибку или null. Решения: использование паттерна «Пустой объект» (Null Object), реализация базового поведения в абстрактном классе фабрики или использование параметров по умолчанию.

Как добавление нового продукта в семейство (новый метод CreateX) влияет на существующий код? Как минимизировать ущерб?: Это вынуждает изменить интерфейс абстрактной фабрики и все его реализации, что является нарушением OCP. Минимизация: использовать метод CreateProduct(string type) (менее типизировано), использовать прототипы или расширять фабрики через композицию.

Когда вместо абстрактной фабрики лучше применить Builder? Опишите критерии выбора?:

    Абстрактная фабрика: Нужен набор разных, но связанных объектов. Важно «ЧТО» создается.

    Builder: Нужен один сложный объект с множеством настроек и этапов сборки. Важен «КАК» (процесс) создается объект.

Приведите пример «протекающей абстракции» при использовании абстрактной фабрики и объясните, что это означает: Это ситуация, когда детали реализации проникают в интерфейс. Например, если метод IUIFactory::CreateButton требует передать Win32_HWND. Это означает, что абстракция «протекла», так как клиент теперь обязан знать о специфике Windows, даже если использует абстрактную фабрику.

Как организовать выбор конкретной фабрики (NY vs Chicago) так, чтобы бизнес-код не знал о регионах/платформах?: Выбор фабрики должен происходить один раз в Composition Root (точке входа) на основе конфигурации или переменных окружения. Бизнес-код должен получать уже готовую фабрику через конструктор (Dependency Injection).

Чем опасна фабрика-синглтон с глобальным состоянием в контексте абстрактной фабрики?: Она затрудняет тестирование (нельзя легко подменить фабрику моком), скрывает зависимости и делает невозможным использование двух разных семейств продуктов одновременно в разных частях приложения.

Как абстрактная фабрика помогает «прибить» совместимость ингредиентов (NY-соус + NY-сыр)? Почему это сложно обеспечить без неё?: Фабрика гарантирует, что внутри NYPizzaFactory метод CreateSauce вернет именно NYSauce. Без нее программист может по ошибке передать ChicagoSauce в NYPizza, и система не сможет отловить это на этапе компиляции, так как оба являются «соусами».

Опишите вариант реализации фабрики в функциональном стиле (через функции/лямбды). Когда это оправдано?: Вместо объекта-фабрики передается набор функций-конструкторов (или словарь лямбд). Это оправдано в небольших системах, где создание объектов не требует сложного состояния, чтобы не плодить классы и интерфейсы.

Какие параметры допустимо передавать в IUIFactory::CreateLabel и какие — недопустимо, и почему?:

    Допустимо: Данные (текст лейбла, координаты), которые не зависят от платформы.

    Недопустимо: Платформенные объекты (указатели на ресурсы ОС, хендлы), так как это привязывает интерфейс к конкретной реализации.

Предложите дизайн API фабрики UI-элементов так, чтобы клиент не передавал платформенные хендлы: Методы должны принимать примитивы или абстрактные структуры данных (например, Rect или Color), а создание и управление системными ресурсами фабрика должна инкапсулировать внутри своих конкретных реализаций.

Что такое composition root и почему он важен при работе с абстрактными фабриками?: Это единственное место в приложении (обычно Main), где создаются конкретные объекты и связываются зависимости. Это важно, так как только здесь мы решаем, какую конкретную фабрику (платформу) запустить, оставляя остальной код чистым от деталей реализации.

Чем «фабрика фабрик» отличается от корректного выбора семейства через composition root?: «Фабрика фабрик» — это дополнительный слой абстракции (часто избыточный), который выбирает фабрику в рантайме. Корректный выбор через Composition Root делает это статично при запуске, что проще в поддержке и тестировании.

Как бы вы реализовали переключение семейства по feature-flag без протекания деталей в домен?: В Composition Root проверяется флаг. Если он активен, в контейнер зависимостей (DI) регистрируется одна реализация фабрики, если нет — другая. Весь доменный код продолжает работать с одним и тем же интерфейсом IFactory.

В каких ситуациях допустимо держать в фабрике кэш и состояние? Когда это превращается в проблему?: Допустимо для неизменяемых объектов (Flyweight) или тяжелых ресурсов. Становится проблемой, когда состояние фабрики влияет на логику создаваемых объектов, делая их поведение непредсказуемым или мешая многопоточности.

Объясните, как абстрактная фабрика помогает снижать стоимость изменения сигнатур конструкторов продуктов: Если сигнатура конструктора конкретного продукта изменилась, вам нужно поправить код только в одном месте — в методе Create... соответствующей конкретной фабрики. Клиенты, использующие фабрику, вообще не заметят изменений.

Какие риски создаёт использование строковых ключей для выбора конкретного продукта внутри фабрики? Чем заменить?: Риски: опечатки, ошибки в рантайме, отсутствие проверки типов. Замена: строго типизированные перечисления (Enum), регистрация классов через типы (Type-safe Map) или Generics.

Как организовать регистрацию продуктов/креаторов в фабрике, чтобы добавление новых типов не требовало редактирования if/else?: Использовать паттерн «Реестр» (Registry). Фабрика хранит карту (Map), где ключом является тип/имя, а значением — указатель на функцию или объект-прототип, создающий продукт.

Приведите пример, когда абстрактная фабрика не нужна, и её использование ухудшит дизайн (YAGNI): Когда в приложении есть всего одна платформа и один набор продуктов, который гарантированно не изменится. Введение абстрактной фабрики в таком случае создаст лишние интерфейсы и классы «на будущее», усложняя чтение кода.

Какие признаки того, что вы неправильно выбрали «ось вариативности» и вам нужен другой паттерн (Strategy/Bridge/DI)?: Если вы замечаете, что ваши фабрики отличаются не набором продуктов, а логикой их взаимодействия или способом выполнения одной и той же задачи, то вам, скорее всего, нужна Стратегия или Мост.

Опишите компромисс: «больше интерфейсов и классов» vs «гарантированная совместимость». Как бы вы аргументировали решение команде?: Аргументация: «Да, у нас стало на 5 классов больше, но теперь мы физически не можем создать "неправильную" мебель. Это исключает целый класс багов в рантайме, которые в будущем обошлись бы нам в разы дороже, чем поддержка этих интерфейсов».

Как обеспечить, чтобы продукты одного семейства не создавали напрямую продукты другого семейства?: Продукты должны принимать другие продукты только через их абстрактные интерфейсы. Сами продукты не должны иметь доступа к фабрикам; вся сборка сложного взаимодействия должна происходить либо в фабрике, либо в клиенте.

Как связать абстрактную фабрику с фабричным методом в одном решении?: Абстрактная фабрика — это интерфейс. Каждая конкретная реализация этой фабрики (например, NYFactory) использует Фабричный метод для создания своих конкретных продуктов (CreatePizza).