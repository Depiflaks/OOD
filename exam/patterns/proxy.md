Паттерн проектирования «Заместитель»

Объясните паттерн Proxy своими словами: какую проблему он решает? 
    Это объект-прослойка, который имеет тот же интерфейс, что и реальный объект. Он решает проблему контроля доступа к объекту, позволяя выполнять дополнительные действия (ленивая инициализация, логирование, проверка прав, кеширование) до или после вызова основного метода, не меняя код самого объекта.

Какие признаки в архитектуре подсказывают, что нужен Proxy, а не просто «вынести код в отдельный класс»? 
    Главный признак — необходимость сохранить тот же интерфейс, что и у целевого класса. Если вам нужно добавить системную логику (сеть, безопасность, кеш), но при этом клиент должен думать, что работает напрямую с бизнес-объектом, используется Proxy.

Опишите минимальную структуру Proxy (Subject / RealSubject / Proxy). Какие зависимости допустимы, а какие приведут к «протеканию абстракции»? 
    Оба класса (Proxy и RealSubject) наследуются от общего интерфейса Subject. Proxy содержит ссылку на RealSubject. Допустима зависимость только через интерфейс. Протекание абстракции возникнет, если Proxy потребует от клиента передачи конкретного типа RealSubject или если методы интерфейса начнут возвращать специфичные для реализации типы данных (например, сетевые сокеты).

Почему важно, чтобы клиент «не знал и не обязан знать», что работает с Proxy? Какие последствия возникают, если клиент начинает делать проверки вида if (obj is Proxy)? 
    Это обеспечивает взаимозаменяемость и соблюдение принципа подстановки Лисков (LSP). Если клиент делает проверки типа, теряется гибкость: вы не сможете заменить один Proxy на другой (например, кеширующий на защищающий) или на реальный объект без правки кода клиента, что ломает полиморфизм.

Чем Proxy принципиально отличается от Adapter? Приведите пример ситуации, где визуально структуры похожи, но намерение разное. 
    Намерение: Adapter меняет интерфейс для совместимости, Proxy — сохраняет его для контроля доступа. Пример: Объект LegacyPrinter. Если мы создаем ModernPrinterAdapter, чтобы он работал через IPrinter — это Adapter. Если мы создаем SecurePrinterProxy с тем же интерфейсом IPrinter, чтобы проверять пароль перед печатью — это Proxy.

Чем Proxy принципиально отличается от Decorator? Сформулируйте критерий, по которому вы точно определите выбор на практике. 
    Критерий: Управление жизненным циклом. Декоратору объект передается извне (агрегация), он лишь добавляет ответственности. Proxy обычно сам создает реальный объект или управляет его существованием (композиция). Если вы создаете объект внутри — это Proxy, если оборачиваете уже готовый — это Decorator.

Кэширование можно реализовать и как Proxy, и как Decorator. Опишите два варианта постановки задачи, которые приведут к разным решениям, и как это отразится на публичном API. 
    1. Proxy: Задача — скрыть факт существования тяжелого ресурса (например, БД). Публичное API не меняется, клиент просто запрашивает данные. 2. Decorator: Задача — добавить опциональное ускорение к уже существующему соединению. В API может появиться фабрика, которая «наслаивает» кеш на переданный объект.

Объясните Virtual Proxy: что именно считается «дорогим» в создании объекта, и как Proxy помогает уменьшить стоимость старта системы? 
    «Дорогим» является выделение большого объема памяти, установка сетевых соединений или тяжелые вычисления в конструкторе. Virtual Proxy заменяет объект «пустышкой», которая создает реальный объект только в момент первого обращения к методу, тем самым ускоряя запуск приложения и экономя ресурсы.

В примере с ImageProxy: почему Proxy хранит «примерный размер» (m_size) до загрузки реального изображения? Какие компромиссы точности/удобства тут заложены? 
    Это нужно для корректной отрисовки макета интерфейса (UI) до того, как само изображение скачано. Компромисс: Мы получаем мгновенную отзывчивость интерфейса ценой возможного визуального скачка, если реальный размер картинки после загрузки окажется другим.

Как бы вы спроектировали Virtual Proxy, если реальный объект может не только долго создаваться, но и часто падать при загрузке? Какие состояния и переходы должны быть у Proxy? 
    Нужно внедрить машину состояний внутри Proxy:

    Состояния: NotInitialized, Loading, Ready, Error.

    Переходы: При вызове метода: NotInitialized -> Loading. При успехе: Loading -> Ready. При сбое: Loading -> Error.

    Логика: Состояние Error может позволять повторную попытку (Error -> Loading).

В ImageProxy::Impl::Draw() используется weak_from_this() и lock(). Объясните, какую проблему это решает в асинхронном callback, и что может пойти не так без этого. 
    Это предотвращает обращение к удаленному объекту. Если Proxy был удален пользователем до того, как пришел ответ из сети, callback попытается обратиться к this (висячий указатель), что вызовет крэш. lock() проверяет, жив ли еще объект.

Как реализовать «частичную функциональность» в Virtual Proxy? Как при этом не сломать LSP? 
    Proxy может возвращать метаданные (имя файла, дата создания), которые он уже знает, не создавая реальный объект. Чтобы не сломать LSP, эти методы должны возвращать корректные значения, соответствующие контракту интерфейса, даже если основной контент еще не загружен.

Что будет считаться «утечкой деталей реализации» Virtual Proxy в клиентский код? Приведите 2–3 примера таких утечек. 
    1. Проброс сетевых исключений (TimeoutException) через интерфейс, который их не предполагает. 2. Метод IsLoaded() в публичном интерфейсе. 3. Задержки (фризы) UI при неявной синхронной загрузке внутри метода.

Объясните Remote Proxy: почему он считается разновидностью Proxy, а не просто сетевым клиентом? Какие свойства делают удалённость прозрачной? 
    Потому что он полностью имитирует интерфейс локального объекта. Свойства прозрачности: идентичные сигнатуры методов и автоматическая инкапсуляция всей логики сети (маршалинг параметров) внутри Proxy, так что клиент не видит разницы между локальным и удаленным вызовом.

В примере с утками: какие обязанности у DuckProxy, а какие — у DuckStub? Почему важно разделять эти роли? 
    * DuckProxy (клиент): сериализует вызов и отправляет по сети.

    DuckStub (сервер): принимает запрос, десериализует и вызывает реальный объект. Разделение нужно для изоляции сетевого протокола от бизнес-логики на обеих сторонах.

Опишите полный путь вызова duck.Fly(...) в Remote Proxy (по шагам, включая сериализацию/десериализацию, обработку ошибок). 
    1. Клиент вызывает Fly(). 2. Proxy пакует имя метода и аргументы в пакет. 3. Пакет отправляется по сокету. 4. Stub на сервере читает пакет. 5. Stub вызывает Fly() у RealDuck. 6. Результат пакуется и летит назад. 7. Proxy получает ответ и возвращает значение клиенту.

В DuckStub::HandleFly параметры парсятся из строки. Какие проблемы появятся при усложнении протокола (версии, бинарные данные, совместимость)? Как бы вы это переработали? 
    Текстовый парсинг медленный и хрупкий. При усложнении возникнут ошибки типов и версионности. Решение: Перейти на типизированную бинарную сериализацию (Protocol Buffers, FlatBuffers), которая поддерживает схемы данных и версионность.

Как корректно моделировать и обрабатывать ошибки в Remote Proxy: таймауты, сетевые сбои, частичные отказы? Что должен «видеть» клиент: исключения, коды ошибок, ретраи? 
    Клиент должен видеть высокоуровневые Domain Exceptions (например, ServiceUnavailable). Логику ретраев (повторных попыток) Proxy должен скрывать внутри себя, если операция идемпотентна.

Что такое «семантическая прозрачность» Remote Proxy: в каких случаях невозможно сделать удалённый вызов полностью эквивалентным локальному? 
    Это идентичность поведения. Она невозможна, если: 1. Передаются указатели/ссылки на память (на другом ПК они невалидны). 2. Есть общие глобальные переменные. 3. Время отклика (latency) на порядки выше.

Как влияет Remote Proxy на контракт методов (идемпотентность, побочные эффекты, повторные вызовы при ретраях)? Приведите пример, где наивный ретрай ломает бизнес-логику. 
    Методы должны быть идемпотентны для безопасных ретраев. Пример: Метод WithdrawMoney(100). Если произошел таймаут ответа, но банк деньги снял, а Proxy сделал ретрай — деньги спишутся дважды.

Расскажите про Protection Proxy: что именно он должен проверять, и почему перенос этих проверок в RealSubject часто ухудшает дизайн? 
    Он проверяет права доступа (RBAC/ACL). Перенос в RealSubject нарушает SRP (принцип единственной ответственности), смешивая бизнес-логику с безопасностью, и усложняет тестирование самого объекта.

В примере DocumentProtectionProxy: почему чтение разрешено всем, а редактирование/удаление — нет. Как бы вы расширили архитектуру, не раздувая Proxy условными операторами? 
    Это классическая модель прав доступа. Для расширения стоит использовать паттерн Strategy или Command, делегируя проверку прав отдельному объекту-авторизатору (Policy), чтобы Proxy не превратился в свалку if/else.

Что лучше сделать при запрете операции в Protection Proxy: молча «return», логировать, бросать исключение, возвращать статус? От чего зависит выбор? 
    Лучше бросать исключение (UnauthorizedAccessException). Выбор зависит от критичности: в UI можно возвращать статус, но для системной логики исключение гарантирует, что программа не продолжит работу с неверными данными.

Опишите угрозы, которые Protection Proxy не решает. Какие архитектурные меры нужны, чтобы прокси действительно защищал? 
    Он не защищает, если клиент может получить доступ к RealSubject в обход Proxy. Меры: Инкапсуляция (сделать RealSubject приватным полем/классом), использование фабрик, которые возвращают только интерфейс.

Что такое Smart Proxy, и чем он отличается от «просто логирования»? Какие признаки указывают, что вы строите именно Smart Proxy? 
    Он добавляет «умное» управление ресурсами: подсчет ссылок (как shared_ptr), блокировку потоков (mutex), CoW. Признак — Proxy берет на себя ответственность за техническое состояние или синхронизацию объекта.

Объясните идею Copy-on-Write как Smart Proxy: какие инварианты должны соблюдаться, чтобы копия создавалась только при модификации? 
    Несколько Proxy ссылаются на одни и те же данные. При вызове константного метода (чтение) данные не копируются. Как только вызывается мутирующий метод, Proxy должен создать глубокую копию данных специально для этого экземпляра.

В примере CoW::Write() (возвращающем ссылку) показана ошибка, когда сохраняют ссылку и меняют данные после копирования. Объясните, почему это ломает CoW, и как вспомогательный тип WriteProxy предотвращает проблему на уровне типов. 
    Если клиент сохранил прямую ссылку на данные, он может менять их в обход контроля Proxy, ломая данные другим пользователям. WriteProxy — это временный объект-обертка, который перегружает operator=. Копирование данных происходит не в момент вызова Write(), а в момент фактического присваивания значения через этот посредник.