Паттерн проектирования "Адаптер" (Adapter)

Формальное определение:

    Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Он выступает в роли переводчика, преобразуя вызовы клиента в формат, понятный адаптируемому объекту.

Ответы на вопросы

Объясните паттерн «Адаптер» своими словами и приведите пример из промышленной разработки, где он является наиболее уместным решением. 
    Адаптер — это объект-прослойка, который делает один интерфейс совместимым с другим, не меняя код существующих классов. В промышленной разработке он уместен при интеграции со сторонним платежным шлюзом (например, Stripe или PayPal): если библиотека шлюза обновится или вы решите сменить провайдера, вам достаточно будет создать новый адаптер, сохранив остальной код приложения неизменным.

Почему изменение интерфейса внешней библиотеки часто приводит к «поломке» системы? Какие свойства архитектуры делают систему особенно уязвимой к таким изменениям? 
    Изменение внешнего интерфейса ломает систему, если клиентский код напрямую вызывает методы библиотеки (тесная связность). Система особенно уязвима, если в ней отсутствует уровень абстракции и зависимости направлены на конкретные реализации (нарушение DIP), что заставляет вносить правки во множество мест при малейшем изменении внешнего API.

В каких ситуациях переписывание клиентского кода является плохой альтернативой адаптеру? Оцените это с точки зрения стоимости сопровождения и рисков. 
    Переписывание — плохая идея, если клиентский код обширен, стабилен и хорошо протестирован. Это увеличивает стоимость сопровождения (нужно тестировать всё заново) и риски регрессии (случайного внесения багов). Адаптер позволяет изолировать изменения и сохранить стабильность основной логики.

Опишите роли Client / Target / Adapter / Adaptee и объясните, какие зависимости между ними допустимы, а какие являются архитектурной ошибкой. Ответ:

    Client: Вызывает методы Target.

    Target: Интерфейс, который ожидает клиент.

    Adapter: Реализует Target и оборачивает Adaptee.

    Adaptee: Класс с несовместимым интерфейсом, который нужно использовать. Допустимо: Client зависит от Target; Adapter зависит от Adaptee. Ошибка: Client зависит напрямую от Adapter или Adaptee; Target зависит от Adapter.

Почему клиент «не должен знать про наличие адаптера»? Какие проблемы возникнут, если клиент начнёт зависеть от конкретного адаптера? 
    Клиент должен зависеть от абстрактного интерфейса (Target), чтобы соблюдался принцип полиморфизма. Если клиент зависит от конкретного адаптера, система становится жесткой: вы не сможете подменить одну библиотеку другой (один адаптер другим) без изменения кода клиента, что лишает паттерн его главного преимущества — гибкости.

Рассмотрите пример «утки и индюшки». Какие именно несовместимости интерфейсов присутствуют в этом примере и как адаптер их устраняет? 
    Утка (Duck) ожидает методы Quack() и Fly(), а индюшка (Turkey) имеет методы Gobble() и Fly(). Адаптер реализует интерфейс Duck и внутри метода Quack() вызывает Gobble(), тем самым устраняя несовместимость имен методов и поведения.

В примере с утками метод Fly() адаптера вызывает Fly() индюшки 5 раз. Почему это важно с точки зрения семантической адаптации, а не только совпадения сигнатур? 
    Семантическая адаптация гарантирует, что поведение объекта соответствует ожиданиям клиента. Индюшка летает на короткие дистанции, в отличие от утки. Чтобы индюшка «выглядела» как утка для клиента, адаптер вызывает её короткий полет 5 раз, имитируя один длинный полет. Это адаптация смысла, а не только названий методов.

Что произойдёт, если адаптер будет реализован формально (методы совпадают), но семантика поведения не соответствует ожиданиям клиента? Приведите пример ошибки проектирования. 
    Система может вести себя непредсказуемо или упасть. Пример: клиент вызывает Save(data) у адаптера БД, ожидая записи на диск, а адаптер лишь сохраняет данные в локальный кэш (формально метод сработал, семантически — нет). При сбое питания данные будут потеряны, так как клиент не знал о «слабой» реализации.

Объясните разницу между объектным адаптером и классовым адаптером. Когда вы выберете один подход вместо другого? 
    Объектный адаптер использует композицию (хранит экземпляр Adaptee внутри). Классовый адаптер использует множественное наследование (наследует и Target, и Adaptee). Объектный адаптер выбирают в 99% случаев за его гибкость; классовый — в C++, когда нужно переопределить часть поведения Adaptee или если Adaptee не имеет подклассов.

Какой адаптер обычно считается более гибким: объектный или классовый? Как это связано с принципами ООП? 
    Объектный адаптер более гибкий, так как он следует принципу «композиция предпочтительнее наследования». Он может адаптировать не только сам класс Adaptee, но и любые его подклассы, что невозможно для классового адаптера.

Какие преимущества даёт классовый адаптер в C++ и какие ограничения он накладывает на архитектуру системы? 
    Преимущества: не нужно писать методы-прокси для каждого вызова (если имена совпадают), есть доступ к protected-членам Adaptee. Ограничения: жесткая связь с конкретным классом Adaptee на этапе компиляции, невозможность адаптировать подклассы динамически.

В каких случаях множественное наследование в классовом адаптере может стать источником проблем? Какие это проблемы (не только технические, но и архитектурные)? 
    Проблемы: техническая — «алмаз смерти» (diamond problem); архитектурная — нарушение SRP (класс становится «всем сразу») и сложность понимания кода из-за смешивания разных иерархий типов в одном объекте.

Рассмотрите слайд про «объём работы»: почему сложность адаптера пропорциональна размеру Target-интерфейса? Какие практики помогают уменьшить эту стоимость? 
    Адаптер обязан реализовать все методы Target-интерфейса. Если в Target 50 методов, адаптер будет громоздким. Уменьшить стоимость помогает принцип разделения интерфейса (ISP) — дробление Target на мелкие, специализированные интерфейсы.

Что такое «замаскированные зависимости от конкретных классов» и почему они мешают внедрению адаптера? Приведите пример кода или ситуации. 
    Это ситуация, когда код формально принимает интерфейс, но внутри делает dynamic_cast к конкретному классу. Это мешает адаптеру, так как он — другой класс. Пример: void Process(IShape* s) { auto r = static_cast<Rect*>(s); ... }. Если мы передадим CircleAdapter, программа упадет.

Почему адаптер легче внедрять в код, который зависит от интерфейсов? Как это связано с DIP (Dependency Inversion Principle)? 
    Если код зависит от интерфейсов, вы можете просто подсунуть ему адаптер вместо оригинального объекта. Это прямая реализация DIP: высокоуровневый модуль (клиент) зависит от абстракции (Target), а не от низкоуровневой реализации (Adaptee).

Можно ли считать адаптер нарушением SRP (Single Responsibility Principle)? Аргументируйте ответ и поясните, где проходит граница ответственности адаптера. 
    Нет, если его единственная ответственность — трансляция. Адаптер нарушает SRP, если начинает содержать сложную бизнес-логику. Его граница ответственности: преобразование данных и делегирование вызовов.

Как адаптер помогает реализовать принцип Open/Closed? Какие изменения в системе должны происходить при смене внешнего API? 
    Он позволяет расширять систему (добавлять новые библиотеки), не модифицируя существующий клиентский код. При смене API вы просто создаете новый класс адаптера и регистрируете его, не трогая стабильную бизнес-логику.

Чем адаптер отличается от фасада (Facade) по цели и эффекту на архитектуру? Приведите пример, где один паттерн подходит, а другой — нет. 
    Адаптер меняет интерфейс для совместимости (обычно 1-к-1). Фасад упрощает интерфейс для удобства (1-к-многим). Если вам нужно подключить новую библиотеку логирования к старому интерфейсу — нужен Адаптер. Если нужно скрыть сложность инициализации 10 подсистем за одной кнопкой — нужен Фасад.

Чем адаптер отличается от прокси (Proxy)? В каких случаях прокси может выглядеть как адаптер и почему важно различать их намерение? 
    Прокси имеет тот же интерфейс, что и оригинал, и контролирует доступ. Адаптер предоставляет другой интерфейс. Прокси может выглядеть как адаптер, если он «подчищает» или слегка меняет типы данных, но их намерения разные: Адаптер — для связи несовместимых, Прокси — для управления доступом.

Чем адаптер отличается от декоратора? Объясните разницу на уровне контракта и намерения. Приведите пример, где путаница приведёт к плохому дизайну. 
    Декоратор сохраняет интерфейс и добавляет новые обязанности. Адаптер меняет интерфейс для совместимости. Путаница (например, использование адаптера для добавления логирования) сделает невозможным прозрачное использование объекта старыми клиентами.

В каких ситуациях адаптер может «прятать» проблемы дизайна и откладывать рефакторинг, вместо того чтобы улучшать систему? 
    Когда адаптер используется для связывания двух плохо спроектированных модулей внутри одного проекта вместо того, чтобы привести их к единому стандарту. Это создает «архитектурный долг», маскируя хаос в интерфейсах.

Допустим, у вас есть несколько внешних библиотек с разными интерфейсами, но одинаковым смыслом. Как бы вы спроектировали систему адаптеров, чтобы клиентский код не зависит от конкретной библиотеки? 
    Я бы выделил единый внутренний интерфейс (Target). Для каждой внешней библиотеки создал бы отдельный класс-адаптер. Выбор конкретного адаптера происходил бы в точке инициализации (Composition Root), а клиент работал бы только с Target.

Что делать, если адаптируемый интерфейс часто меняется (частые breaking changes)? Как организовать адаптеры и тесты, чтобы изменения локализовывались? 
    Нужно использовать автоматизированные контрактные тесты, которые проверяют соответствие адаптера и внешней библиотеки. Изменения должны локализоваться в одном классе адаптера, а клиентский код должен оставаться изолированным за стабильным интерфейсом Target.

Какие виды тестов наиболее важны для адаптера: модульные, контрактные, интеграционные? Что именно должен гарантировать тест адаптера? 
    Наиболее важны интеграционные и контрактные тесты. Тест должен гарантировать, что вызов метода Target-интерфейса приводит к корректному вызову метода Adaptee с правильными параметрами и возвращает ожидаемый результат.

Рассмотрите пример с ListView и IListViewDataSource. Почему это пример адаптера, даже если он выглядит как «просто интерфейс»? Где здесь Target и Adaptee? 
    Это адаптер, потому что он адаптирует произвольные данные под требования визуального списка. Target — это интерфейс IListViewDataSource (методы GetCount, GetItem). Adaptee — это ваша сырая коллекция данных (например, vector<User>).

Почему вариант «передавать массив IListItemView» (готовые визуальные элементы) считается плохим решением? Объясните с точки зрения производительности, архитектуры и ответственности. 
    Плохо, так как: 1) Память: хранение тысяч готовых View-объектов накладно. 2) Архитектура: данные становятся привязаны к визуальному представлению. 3) Ответственность: источник данных не должен знать о том, как рисовать элементы (нарушение SRP).

Как адаптер в ListView помогает реализовать ленивое создание элементов (on-demand)? Какие преимущества это даёт? 
    Список запрашивает у адаптера конкретный элемент по индексу только тогда, когда он должен появиться на экране. Это позволяет работать с бесконечными списками при минимальном потреблении памяти (создается только 10-20 видимых элементов).

Приведите пример адаптера для подключения клиента к нескольким TTS-сервисам. Какие интерфейсы вы бы сделали целевыми, и какие проблемы интеграции адаптер должен скрывать? 
    Целевой интерфейс: ITextToSpeech с методом Speak(string text). Адаптеры скроют: различия в JSON-протоколах (REST vs gRPC), способы авторизации (API-ключи vs токены), а также разные коды ошибок и форматы аудио-ответов.

Что такое функциональный адаптер (адаптация функции к другой сигнатуре/контракту)? Приведите пример преобразования входных данных и объясните, почему это тоже «Адаптер». 
    Это обертка над функцией (например, лямбда или std::bind), которая меняет количество или тип аргументов. Пример: клиент ждет void(double), а функция принимает void(int). Мы создаем лямбду, которая округляет double и вызывает оригинал. Это адаптер, так как он устраняет несовместимость сигнатур.

Приведите пример функционального адаптера, который превращает синхронную функцию в асинхронную (sync → async). Какие ограничения и гарантии должен соблюдать такой адаптер? 
    Адаптер запускает синхронную функцию в отдельном потоке (например, через std::async). Ограничения: он должен гарантировать потокобезопасность передачи данных и корректно обрабатывать исключения, возникшие в другом потоке, возвращая их через future или callback.