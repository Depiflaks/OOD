Domain-Driven Design - 2

Почему инварианты должны проверяться внутри домена, а не в UI/контроллере/SQL? Приведите пример инварианта и место его проверки. 
        Это гарантирует соблюдение правил вне зависимости от того, как вызывается метод. Инвариант: «баланс счета не может быть отрицательным». Метод проверки: внутри метода Account.Withdraw(amount), который бросает исключение при нарушении правила.

Что такое “явные границы ответственности” в DDD? Как bounded context и aggregate помогают держать эти границы? 
        Это четкое понимание того, где заканчивается одна бизнес-задача и начинается другая. Bounded Context изолирует смыслы терминов, а Aggregate обеспечивает целостность данных внутри своих границ, запрещая прямое изменение своих частей извне.

Что означает “изоляция домена от инфраструктуры”? Какие зависимости и конструкции являются “запахом” загрязнённого домена? 
        Домен не должен знать о деталях сохранения или передачи данных. «Запах»: наличие атрибутов БД (типа [Table], [Column]), JSON-аннотаций, ссылок на HttpContext, SqlClient или логику отправки email внутри доменных сущностей.

Что в DDD понимается под “эволюцией модели”? Как явные границы помогают безопасно проводить рефакторинг домена? 
        Это процесс уточнения и изменения модели при получении новых знаний о бизнесе. Границы Bounded Context позволяют менять внутреннюю реализацию одного модуля, не опасаясь сломать другие части системы, так как взаимодействие идет через стабильные контракты.

Дайте определение Ubiquitous Language. Как вы будете поддерживать его актуальность в команде на длинной дистанции? 
        Единый язык, используемый и экспертами, и разработчиками, и в коде. Поддержка: пресечение использования сленга, обновление глоссария, рефакторинг имен в коде сразу после изменения терминологии в бизнесе.

“Один термин — одно значение”. Почему это правило работает внутри bounded context, и почему оно может не работать между контекстами? 
        Внутри контекста термин однозначен для решения конкретной задачи. Между контекстами один и тот же объект выполняет разные роли (например, «Пользователь» в контексте авторизации — это логин/пароль, а в контексте профиля — это ФИО и адрес).

Приведите примеры плохих и хороших названий в коде. Как вы объясните, что нейминг — не “косметика”, а инструмент дизайна? 
        Плохо: Process(data), UpdateStatus(4). Хорошо: ApplyDiscount(percentage), ShipOrder(). Нейминг — инструмент дизайна, так как он делает намерения кода явными, сокращая время на понимание и снижая риск логических ошибок.

Что такое bounded context как “контейнер смысла”? Почему bounded context — это не просто папка/namespace в коде? 
        Это граница, внутри которой модель остается логически целостной. Это не просто папка, а архитектурный барьер, часто имеющий свою БД, свою команду разработки и свой набор терминов (Ubiquitous Language).

На примере e-commerce объясните, почему один термин (“Order/Заказ”) имеет разные значения в Sales/Billing/Shipping/Inventory/Reporting и почему нельзя слить это в один класс. 
        В Sales важна цена и скидки, в Shipping — вес и адрес, в Inventory — наличие на складе. Слияние в один класс создаст «божественный объект», перегруженный данными и связями, который станет невозможно поддерживать и изменять без побочных эффектов.

Что такое Context Map и какую проблему он решает? Какие вопросы он помогает прояснить между командами? 
        Это визуальная схема связей между Bounded Contexts. Она решает проблему неопределенности интеграций, проясняя: кто владеет контрактом, как передаются данные и как изменения в одном контексте повлияют на другие.

Объясните направления зависимостей на Context Map: что означает “стрелка”, кто от кого зависит и кто адаптируется? 
        Стрелка указывает на направление зависимости (U — Upstream, D — Downstream). Тот, кто Downstream, зависит от решений и контрактов, принятых Upstream-командой, и вынужден под них адаптироваться.

Сравните типы интеграции контекстов: Shared Kernel, Customer/Supplier, Conformist, ACL. Для каждого назовите типичный сценарий применения и главный риск. 
        1. Shared Kernel: общий код (библиотека); риск — сильная связанность. 2. Customer/Supplier: планируемые изменения по запросу; риск — задержки в разработке Supplier. 3. Conformist: полное подчинение чужому API; риск — невозможность влиять на модель. 4. ACL (Anticorruption Layer): переводчик/адаптер; риск — сложность реализации.

Объясните, почему bounded context и микросервис — не синонимы. В каких случаях один контекст разумно оставлять внутри модульного монолита? 
        Bounded Context — это логическая граница, а микросервис — физическая (развертывание). Разумно оставлять контекст в монолите, если нагрузка невелика и не требуется независимое масштабирование, чтобы избежать сложности сетевых вызовов.

Что такое Event Storming, какую роль он играет в DDD и почему его считают мостом от стратегического анализа к тактическому дизайну? 
        Это воркшоп по быстрому моделированию бизнес-процессов через события. Он позволяет найти границы контекстов (стратегия) и выявить конкретные сущности и команды (тактика), объединяя видение бизнеса и разработки.

Объясните CQRS: в чём смысл разделения команд и запросов, почему read model ≠ domain model, и в каких случаях CQRS стоит избегать. 
        Смысл в использовании разных моделей для записи (консистентность) и чтения (производительность). Read model — это денормализованные данные для UI. Избегать стоит в простых приложениях, где накладные расходы на две модели и синхронизацию превышают выгоду от масштабирования.