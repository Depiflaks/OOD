Архитектура GUI-приложений. Document-View

    Объясните, какую проблему Smart UI решает “быстро”, и почему эта же особенность превращается в архитектурный долг по мере роста приложения. 
        Smart UI позволяет мгновенно создать работающий прототип, привязывая бизнес-логику напрямую к обработчикам событий кнопок. Это превращается в долг, так как логика размазывается по UI-коду, что делает невозможным автоматическое тестирование, переиспользование кода и поддержку нескольких представлений одних и тех же данных.

    Опишите паттерн Document–View своими словами: какие обязанности у Document, а какие у View (минимум 3 пункта на каждый). 
        Document (Модель) отвечает за хранение данных, их целостность/валидацию и сохранение/загрузку в файл. View (Представление) отвечает за отрисовку данных на экране, преобразование координат пользователя в логические координаты документа и обработку фокуса/выделения.

    Почему в Document–View считается принципиальным, что состояние отделено от визуального представления? Какие изменения в разработке это упрощает? 
        Это позволяет менять UI, не затрагивая данные, и наоборот. Это упрощает добавление новых способов визуализации (например, график и таблица для одного набора чисел) и позволяет тестировать логику документа без запуска графической оболочки.

    Как событийно-ориентированная модель GUI (цикл сообщений, IoC) влияет на взаимодействие Document и View? Где должен “жить” код реакции на события пользователя? 
        Фреймворк перехватывает ввод и вызывает методы View. Код реакции живет во View: он интерпретирует клик (например, как «удаление элемента») и вызывает соответствующий метод Document, который уже меняет данные.

    В каких случаях Document–View предпочтительнее MVC/MVP/MVVM и почему? Сформулируйте критерии выбора. 
        Когда приложение ориентировано на работу с файлами (редакторы), данные монолитны, и требуется высокая производительность отрисовки. Критерии: один основной источник данных, необходимость реализации Undo/Redo на уровне документа и тесная интеграция с системным API окон.

    Какие требования к интерфейсу Document (модели): какие методы он обязан предоставлять, чтобы View могла корректно обновляться и при этом не нарушать инкапсуляцию? 
        Document должен предоставлять методы доступа к данным «только для чтения» (геттеры), методы изменения состояния и интерфейс для подписки на уведомления об изменениях (Observer).

    Зачем Document предоставляет механизм уведомления об изменениях? Какие сценарии становятся невозможными или слишком хрупкими без уведомлений? 
        Чтобы View могла автоматически перерисоваться при изменении данных (например, из другого окна или фонового процесса). Без этого невозможна синхронизация нескольких окон, отображающих один документ, или реализация функций совместной работы.

    Какие риски возникают из-за хранения “сырых” указателей на слушателей в Document? Как можно улучшить дизайн с точки зрения безопасного владения/времени жизни объектов? 
        Риск обращения к удаленному объекту (dangling pointer), если View закроется, а Document попытается её уведомить. Улучшить дизайн можно через использование std::weak_ptr или специализированных объектов-подписок (scoped connections), которые отписываются автоматически при уничтожении.

    Объясните, зачем View подписывается на Document в OnCreate, а отписывается в OnDestroy. Почему подписка/отписка не должна быть “где-то в конструкторе/деструкторе” без учёта жизненного цикла окна? 
        Окно может существовать как объект в памяти, но не быть активным или созданным в ОС. Подписка в OnCreate гарантирует, что мы тратим ресурсы на обновление только тогда, когда окно реально отображается, а отписка в OnDestroy предотвращает утечки памяти и вызовы к уже «полумертвому» окну.

    *Что произойдёт, если забыть вызвать RemoveListener(this) при уничтожении View? Опишите возможные симптомы и типы багов. 
        Произойдет Access Violation или сегментированная ошибка при следующем изменении данных в Document. Симптомы: случайные крэши приложения в момент, когда пользователь закрыл одно окно и продолжает работать в другом.

    Почему View : private IDocumentListener (приватное наследование) может быть осознанным решением? Чем это отличается от public-наследования в плане API и инкапсуляции? 
        Это скрывает методы уведомления (OnUpdate) от внешних пользователей View, делая их частью внутренней реализации. В отличие от публичного наследования, это предотвращает вызов методов слушателя кем-либо, кроме самого Document.

    Почему у IDocumentListener деструктор protected и невиртуальный? Какой контракт использования интерфейса этим выражается, и какие ошибки это предотвращает? 
        Это запрещает удаление объекта через указатель на интерфейс (delete pListener). Это предотвращает ошибки случайного удаления View классом Document, так как Document не владеет View, а только уведомляет её.

    Предположим, что у одного Document есть несколько View (например, главное окно и отдельная панель/индикатор). Как обеспечить согласованность обновлений и избежать “лишних” перерисовок? 
        Использовать «умные» уведомления с флагами изменений (Hint). Document передает в OnUpdate информацию о том, что именно изменилось, чтобы View могла перерисовать только затронутую область, а не всё окно.

    Чем Document–View отличается от Smart UI по тестируемости? Какие unit-тесты появляются для Document, и какие всё равно остаются сложными? 
        Document можно полностью покрыть Unit-тестами (логика данных, расчеты, загрузка файлов). Сложными остаются тесты самой отрисовки (пиксельная точность) и сложные сценарии взаимодействия пользователя с мышью во View.

    Какие принципы SOLID усиливаются при переходе от Smart UI к Document–View, а какие могут быть нарушены при неаккуратной реализации? 
        Усиливается SRP (разделение логики и UI) и OCP (новые View без правки Document). Нарушиться может LSP, если иерархия документов или слушателей станет слишком запутанной.

Архитектура GUI-приложений. Model-View-Controller
Shutterstock

    Опишите MVC своими словами: какие обязанности у Model, View, Controller, и какие признаки говорят, что границы ответственности нарушены? 
        Model хранит данные и бизнес-логику. View отображает данные и следит за изменениями модели. Controller интерпретирует действия пользователя и отдает команды модели. Границы нарушены, если View сама меняет данные в базе или если Controller содержит алгоритмы отрисовки.

    Объясните, как событийно-ориентированная модель GUI и инверсия управления фреймворком влияют на то, где должен находиться код обработки действий пользователя в MVC. 
        Фреймворк владеет циклом событий. Когда происходит клик, управление передается Controller-у. Он является «точкой входа» для обработки намерений пользователя, преобразуя UI-события в бизнес-команды.

    Сравните Smart UI и MVC: какие именно проблемы Smart UI решает “быстро”, и какие архитектурные ограничения MVC устраняет? 
        Smart UI решает скорость написания «на коленке». MVC устраняет жесткую связность, позволяя заменять UI (например, Web-интерфейс вместо Desktop) без переписывания логики и облегчая параллельную разработку.

    Почему в MVC обычно запрещают View напрямую модифицировать Model? Опишите минимум два класса ошибок, которые это предотвращает. 
        Это предотвращает обход бизнес-правил (валидации) и появление «зомби-состояний», когда UI изменился, а логика приложения об этом не знает. Также это избавляет от циклов обновлений (View меняет Model -> Model уведомляет View).

    Из чего состоит “контур обновления UI” в MVC? Разберите два сценария обновления View: по уведомлению модели и по уведомлению от ОС/фреймворка. 
        Контур: Событие -> Controller -> Model -> Notification -> View. Сценарий 1 (от модели): данные изменились, все View перерисовались. Сценарий 2 (от ОС): окно было перекрыто другим, ОС просит View просто перерисовать накопленный буфер без запроса к модели.

    Объясните тезис: “Представление в MVC имеет сильную зависимость от модели”. Какие плюсы даёт такая зависимость, и какие минусы приносит (особенно для тестирования)? 
        View знает структуру модели, чтобы эффективно забирать данные. Плюс: простота реализации (View берет что нужно). Минус: View сложно тестировать без создания реального или сложного мок-объекта модели.

    Чем отличается View от widgets? Почему виджеты не должны знать о модели, а View отвечает за синхронизацию состояния виджетов? 
        Виджеты (кнопка, список) — это универсальные кирпичики. View — это конкретный экран. Если виджет узнает о модели, он перестанет быть универсальным. View связывает данные модели с конкретными свойствами виджетов (текст модели -> свойство .text кнопки).

    В чём смысл фразы “представление — это не только графика”? Как бы вы встроили звук/вибрацию в MVC, чтобы не нарушить SRP и границы слоя представления? 
        Представление — это любой способ вывода. Звук и вибрация — это «невидимые» View. Они так же подписываются на изменения модели и при наступлении события (например, OnDataSaved) воспроизводят аудио, не зная о графической части.

    В каких случаях это правило "контроллер обычно связан с представлением 1 к 1" полезно, а в каких — становится ограничением? Приведите пример и альтернативу. 
        Полезно для простых форм. Ограничение: когда одно действие (например, «Удалить») доступно из меню, тулбара и горячей клавиши. Альтернатива: использование паттерна Command, где разные контроллеры вызывают одну общую команду.

    Контроллер “обычно направляет запросы на изменение модели”, но может модифицировать и View. В каких ситуации прямое обновление View контроллером оправдано, а когда это архитектурный запах? 
        Оправдано для чисто визуальных вещей (показать спиннер загрузки, подсветить поле красным при ошибке ввода). «Запах»: если контроллер сам вычисляет координаты отрисовки или напрямую меняет текст, который должен был прийти из модели.

    Опишите, какие “сервисы” должна предоставлять модель в MVC. Где проходит граница между доменной логикой и “логикой приложения”? 
        Модель предоставляет методы CRUD, поиск и уведомления. Доменная логика — это правила бизнеса (например, «скидка 10%»). Логика приложения — это задачи типа «отправить отчет по почте после сохранения».

    Что означает “модель полностью независима от UI”? Какие виды зависимостей допустимы, а какие недопустимы? 
        Модель не должна импортировать библиотеки UI (типа System.Drawing или Qt). Допустимы зависимости от интерфейсов-слушателей. Недопустимы зависимости от конкретных классов окон или координат экрана.

    Объясните, что такое целостность данных в модели и почему она не всегда равна “валидности”. Приведите пример UI-сценария, где модель проходит через невалидные состояния к валидному. 
        Целостность — это внутренняя непротиворечивость (ссылки не битые). Валидность — соответствие бизнес-правилам. Пример: заполнение длинной анкеты. Пока все поля не заполнены, модель «невалидна» для сохранения, но она «целостна» как объект в памяти.

    Сравните пассивную, активную и ленивую модель как стратегии уведомления. Какие компромиссы по синхронизации, сложности и контролю перерисовок у каждой? 
        Пассивная: контроллер сам говорит View обновиться (просто, но риск рассинхрона). Активная: модель сама рассылает уведомления (надежно, но сложнее). Ленивая: View проверяет изменения только при получении фокуса (экономит ресурсы, но данные могут устареть).

    Почему пассивная модель осложняет синхронизацию нескольких View, если модель меняют разные контроллеры? Опишите конкретный сценарий рассинхронизации и способ исправления. 
        Сценарий: Контроллер А меняет данные и обновляет View А. View Б, связанная с той же моделью, не знает об изменениях и показывает старые данные. Исправление: переход к активной модели (Observer).

    Если приложение состоит из нескольких слабосвязанных MVC-триад, какие практики помогают не превратить систему в “комок связей”? 
        Использование глобальной шины событий (Event Bus), посредников (Mediator) или паттерна Coordinator для управления навигацией между экранами.

Архитектура GUI-приложений. Model-View-Presenter / MVVM

    Объясните, зачем в архитектурах уровня MVP/MVVM стремятся сделать так, чтобы View не знало модель напрямую. Какие проблемы это решает? 
        Это полностью изолирует UI от структуры данных. Решает проблему сложности тестирования View и позволяет менять формат данных в модели без необходимости переписывать код привязки в UI.

    Сравните Smart UI и Passive View: что именно “переезжает” из View наружу, и почему это повышает тестируемость? 
        Из View уходит вся логика принятия решений (даже простейшие if). View превращается в набор геттеров/сеттеров свойств. Тестируемость растет, так как теперь можно протестировать поведение UI, просто вызывая методы Presenter и проверяя, какие свойства он установил во View-заглушке (Mock).

    Опишите паттерн Passive View: какие обязанности остаются у View, а какие переходят к Controller/Presenter? Почему подчёркивается “отсутствие связей между моделью и представлением”? 
        View только отображает примитивы (строки, числа) и транслирует события ввода. Presenter берет данные из модели, форматирует их (например, превращает дату в строку) и пушит во View. Связи отсутствуют, чтобы View была абсолютно «глупой» и заменяемой.

    Чем Supervising Controller отличается от “полностью пассивного” подхода, и почему формула “MVP = SupervisingController + PassiveView” может быть полезной? 
        В Supervising Controller используется простая привязка данных (Data Binding) для простых полей, а сложная логика остается в Presenter. Формула помогает найти баланс между лаконичностью кода (Binding) и тестируемостью (Passive View для сложной логики).

    В MVP Presenter является посредником между Model и View. Опишите полный цикл: событие пользователя → Presenter → Model → обновление View. 
        Пользователь жмет «Save» -> View вызывает метод presenter.OnSave() -> Presenter забирает данные из полей View -> Presenter вызывает model.Save(data) -> После успеха Presenter вызывает view.ShowSuccessMessage().

    Почему в MVP Presenter не должен содержать UI-кода и обращаться к View только через интерфейс? Каким ООП-принципам это соответствует? 
        Чтобы Presenter можно было запускать в Unit-тестах без графической среды. Это соответствует Dependency Inversion (зависимость от абстракции интерфейса View) и SRP.

    Что такое View State в MVP? Приведите примеры “представленческого состояния”, которое не относится к предметной области. 
        Это состояние, нужное только для работы UI. Примеры: текущий выбранный индекс в списке, развернута ли группа в дереве, цвет подсветки ошибки, активная вкладка.

    Объясните, что означает “Presenter инкапсулирует преобразование данных модели в формат, удобный для View”. Чем опасно делать эти преобразования прямо в View? 
        Модель может отдавать double, а View должна показать его с валютой и цветом. Если делать это во View, логику форматирования нельзя будет протестировать автоматически, и она будет дублироваться во всех подобных экранах.

    Опишите подход Presenter First. Почему в нём Presenter может “вообще не иметь публичных методов”, и как тогда выглядят границы и точки входа? 
        Presenter создается первым и сам подписывается на события интерфейса View и события Модели. Границами служат интерфейсы, а точкой входа — конструктор Presenter, где происходит связывание.

    Сравните MVP и MVC: кто является “инициатором” обновления View, и почему в MVP обычно легче писать изолированные тесты поведения UI? 
        В MVC модель уведомляет View. В MVP инициатором часто является Presenter. В MVP легче тестировать, так как Presenter управляет View через четкий интерфейс, который легко подменить моком.

    В каких ситуациях MVP предпочтительнее MVVM (и наоборот)? Приведите критерии выбора, связанные с фреймворком, сложностью UI и командой. 
        MVP лучше, когда нет встроенного механизма Binding (WinForms, старый Android, C++). MVVM лучше, когда фреймворк поддерживает мощный биндинг (WPF, SwiftUI, Vue.js). MVP дает больше контроля, MVVM — меньше шаблонного кода.

    Опишите MVVM: роли Model / View / ViewModel, и какие зависимости допустимы между ними (в идеальном варианте). 
        Model — данные. View — визуальный слой. ViewModel — состояние UI и команды. Зависимости: View знает о ViewModel, ViewModel знает о Модели. Модель и ViewModel не знают о View.

    Почему ViewModel “не должна зависеть от конкретного класса View”? Какие типичные ошибки приводят к скрытой зависимости на UI? 
        Чтобы ViewModel была переиспользуемой и тестируемой. Ошибки: передача UI-контролов (Button, TextBox) в параметры методов ViewModel или использование классов типов из UI-библиотек (например, System.Windows.Media.Color).

    Как в MVVM реализуется передача действий пользователя без вызовов методов ViewModel из кода View? Какие архитектурные преимущества это даёт? 
        Через команды (Commands). Кнопка привязывается к свойству-команде во ViewModel. Это позволяет декларативно описывать поведение в XAML/шаблоне и легко подменять логику нажатия.

    Что такое двусторонний data binding, и какие риски он несёт? Как эти риски контролировать? 
        Это когда изменения в UI сразу меняют ViewModel, и наоборот. Риски: трудно отлаживаемые циклы обновлений и неожиданные изменения модели при вводе. Контроль: валидация на уровне сеттеров и использование режимов OneWayToSource там, где это уместно.

    Зачем ViewModel уведомляет View об изменениях (например, через INotifyPropertyChanged)? Какие проблемы возникнут, если уведомления будут “слишком частыми” или “слишком редкими”? 
        Чтобы View обновила привязанные поля. Слишком частые — падение производительности UI. Слишком редкие — пользователь видит устаревшие данные («фризы» значений).

    Сравните стратегии уведомления модели (пассивная/активная/ленивая) с точки зрения MVP и MVVM: где чаще какая стратегия уместна и почему? 
        В MVP чаще активная (через Presenter). В MVVM — активная со стороны ViewModel (через Binding) и часто пассивная со стороны Модели (ViewModel сама опрашивает модель при необходимости).

    Объясните тезис “модель обеспечивает целостность данных, но не всегда валидность”. Как это отражается на дизайне Presenter/ViewModel при вводе данных пользователем? 
        ViewModel может хранить «промежуточное» невалидное значение (например, пустую строку возраста), пока пользователь печатает. Presenter/ViewModel должны блокировать кнопку «Ок», пока модель не сообщит о полной валидности.

    Опишите, как бы вы тестировали логику Presenter или ViewModel без реального UI: какие Test Double (stub/mock/spy/fake/dummy) вы бы использовали и для чего именно? 
        Использовал бы Mock для интерфейса View (проверить вызовы методов отрисовки), Stub для Модели (вернуть фиксированные данные) и Spy, чтобы убедиться, что команды были вызваны в правильном порядке.