Принцип инверсии зависимостей (DIP)

Сформулируйте принцип инверсии зависимостей (DIP) своими словами. Чем он отличается от «просто использовать интерфейсы»? 
        DIP утверждает, что модули верхнего уровня не должны зависеть от модулей нижнего уровня; оба должны зависеть от абстракций. Отличие от «простого использования интерфейсов» в том, что интерфейс должен принадлежать (владеться) верхнему уровню и описывать его потребности, а не просто копировать сигнатуры методов конкретного класса инфраструктуры.

Что такое «модуль верхнего уровня» и «модуль нижнего уровня»? Приведите примеры из реального приложения (UI, use case, БД, сеть и т.д.). 
        Модуль верхнего уровня содержит бизнес-правила и логику приложения (Use Cases), а модуль нижнего уровня — технические детали реализации (БД, работа с сетью, UI, файловая система). Пример: ProcessOrderUseCase (верхний уровень) и PostgresSQLDatabase (нижний уровень).

Почему зависимости от БД, UI, файловой системы и сетевых библиотек считаются «нестабильными»? Какие виды изменений чаще всего происходят в этих деталях? 
        Они нестабильны, так как часто меняются по внешним причинам: обновление сторонних библиотек, смена провайдера (например, с AWS на Azure), изменение схемы данных или смена графического фреймворка. Эти детали подвержены технической моде и внешним API.

Объясните идею «зависимости должны быть направлены на абстракции». Как это снижает хрупкость архитектуры? 
        Логика завязывается на стабильные контракты, а не на конкретный код. Это снижает хрупкость, так как изменение или замена реализации (например, замена SQL на NoSQL) не ломает бизнес-логику, поскольку контракт (интерфейс) остается прежним.

В примере AddUserUseCase -> SqlUserRepository: перечислите минимум 3 проблемы такого дизайна с точки зрения DIP и сопровождения. 
        1. Невозможность юнит-тестирования логики без реальной базы данных. 2. Жесткая привязка бизнес-логики к конкретной SQL-реализации. 3. Необходимость менять Use Case при изменении способа хранения данных.

Почему вызов Connect() внутри use case является тревожным сигналом? Что он говорит о границах ответственности и зависимостях? 
        Это утечка инфраструктурных деталей в бизнес-логику. Это говорит о том, что границы ответственности стерты: Use Case начинает управлять жизненным циклом ресурсов, о которых он не должен ничего знать (например, сокетами или строками подключения).

В исправленном примере с IUserRepository: что именно стало «стабильной абстракцией» и почему она должна принадлежать верхнему уровню, а не инфраструктуре? 
        Интерфейс IUserRepository стал стабильной абстракцией. Он принадлежит верхнему уровню, потому что именно бизнес-логика диктует правила: какие данные ей нужны для работы, а инфраструктура обязана подстроиться под эти требования.

Как изменится система, если завтра нужно заменить SQL на REST API или in-memory хранилище? Опишите, какие файлы/модули должны измениться при соблюдении DIP. 
        Модули с бизнес-логикой останутся нетронутыми. Изменятся только инфраструктурные модули (создастся новый класс RestUserRepository) и «композиционный корень», где регистрируются зависимости.

Объясните, почему «реализация зависит от абстракции, а не наоборот» — это инверсия направления зависимости. Что именно «инвертируется»? 
        Традиционно логика вызывает (зависит от) инструменты. При инверсии инструмент (реализация) вынужден реализовывать интерфейс, определенный логикой. Инвертируется направление контроля: теперь не логика идет к инструментам, а инструменты «приходят» в логику через абстракции.

Чем DIP отличается от Dependency Injection (DI)? Можно ли соблюдать DIP без DI-контейнера? Приведите пример. 
        DIP — это архитектурный принцип (что делать), а DI — технический прием поставки зависимостей (как делать). DIP можно соблюдать вручную: например, передав объект конкретного класса, реализующего интерфейс, через конструктор: var service = new UseCase(new SqlRepo());.

Что такое «композиционный корень» (composition root) и зачем он нужен при соблюдении DIP? Где он обычно находится в приложении? 
        Это единая точка в приложении, где создаются объекты и связываются их зависимости. Он нужен, чтобы избежать размазывания логики создания объектов по всему коду. Обычно находится в методе Main или в стартовых скриптах приложения.

Назовите способы управления созданием объектов при DIP: конструкторная инъекция, фабрики, DI-контейнер. В каких случаях вы выберете каждый из них? 
        1. Конструкторная инъекция: для большинства постоянных зависимостей. 2. Фабрики: когда объект нужно создать динамически во время выполнения. 3. DI-контейнер: в крупных системах для автоматизации сборки сложных графов объектов.

Что означает «стабильные абстракции»? Какие признаки помогают понять, что абстракция действительно стабильна и правильно выделена? 
        Это интерфейсы, которые не меняются при смене технологий. Признаки: использование терминов предметной области (а не технических), отсутствие привязки к конкретным форматам (JSON, SQL) и независимость от внешних библиотек.

Почему правило «не наследуйте конкретные классы» связано со стабильностью архитектуры? В чём риск наследования от изменчивой реализации? 
        Наследование от конкретного класса жестко связывает вас с его внутренними ошибками и побочными эффектами. Риск в том, что любое изменение в базовом классе может непредсказуемо сломать всех наследников (проблема хрупкого базового класса).

Приведите пример нарушения DIP через транзитивные зависимости (когда верхний уровень начинает “видеть” детали нижнего). Как вы бы это исправили? 
        UseCase использует Repo, который возвращает SqlDataReader (тип из библиотеки SQL). UseCase теперь косвенно зависит от SQL. Исправление: Repo должен возвращать доменные сущности или DTO, определенные на верхнем уровне.

Как DIP влияет на тестируемость? Опишите, как вы протестируете AddUserUseCase, не поднимая реальную базу данных. 
        DIP делает тестирование легким через использование моков. В тест AddUserUseCase вместо реальной БД передается «заглушка» (In-memory mock), реализующая IUserRepository, что позволяет мгновенно проверить логику.

Приведите пример, когда абстракция выделена неправильно (слишком широкая или «техническая») и DIP приводит к усложнению. Как бы вы переработали дизайн? 
        Интерфейс IDataSaver с методом SaveToXmlAndSendToFtp. Это техническая абстракция. Нужно переработать её в доменную: IUserRegistry с методом Register(User), скрыв детали FTP/XML внутри реализации.

В каких случаях DIP может быть избыточным? Приведите пример небольшого проекта, где применение DIP ухудшит ситуацию, и объясните почему. 
        В маленьких скриптах, прототипах или утилитах «на один раз». Внедрение интерфейсов и DI в скрипте на 100 строк лишь раздует код и усложнит его понимание без какой-либо выгоды в будущем.

Как DIP связан с архитектурными стилями Clean Architecture / Hexagonal Architecture? Опишите, какие слои обычно защищаются от изменений и за счёт чего. 
        DIP — это фундамент этих стилей. Бизнес-логика (ядро) находится в центре и не зависит ни от чего. Инфраструктурные слои зависят от интерфейсов ядра, защищая ядро от изменений во внешнем мире (БД, UI, веб-сервисы).
Shutterstock

Представьте, что вы делаете код-ревью. Какие вопросы и проверки вы используете, чтобы понять: зависимости направлены правильно и DIP соблюдён осознанно, а не «ради интерфейсов»? 
        1. «Где определен этот интерфейс: в папке с логикой или в папке с БД?» 2. «Изменится ли этот интерфейс, если мы заменим SQL на JSON-файл?» 3. «Просачиваются ли технические типы данных (вроде DbRow) в бизнес-логику?».