Принцип разделения интерфейса (ISP)

    Сформулируйте принцип ISP своими словами. Почему «клиенты не должны зависеть от методов, которые они не используют» — это про архитектуру, а не про удобство API? 
        Большие интерфейсы нужно разделять на маленькие и специфические. Это про архитектуру, так как предотвращает «заразную» зависимость: изменение неиспользуемого метода не должно вызывать перекомпиляцию и перетестирование всех клиентов.

    Что именно считается «клиентом интерфейса» в контексте ISP? Приведите примеры клиентов на уровне классов, модулей и компонентов. 
        Это любой код, который использует интерфейс. На уровне классов — объект, вызывающий метод; на уровне модулей — библиотека, зависящая от API другой библиотеки.

    Объясните, почему «толстый» интерфейс увеличивает связанность системы, даже если лишние методы никогда не вызываются. 
        Возникает физическая зависимость на уровне исходного кода. Даже если метод не вызывается, клиент обязан знать о типах аргументов этого метода, что тянет за собой лишние зависимости и файлы.

    В примере IMultiFunctionDevice: какие конкретные зависимости являются лишними для функции PrintReport и почему это важно? 
        Лишними являются зависимости от методов Scan и Fax. Это важно, так как при изменении протокола сканирования придется пересобирать модуль генерации отчетов, который к сканированию не имеет отношения.

    Почему пустые реализации или throw в методах Scan/Fax у SimplePrinter — плохой признак? Как это связано с корректностью модели и качеством дизайна? 
        Это признак того, что SimplePrinter принудительно привели к типу, которым он не является. Это ломает LSP и указывает на ошибку в дизайне — интерфейс слишком широк и не разделяет роли.

    Опишите «каскадные изменения», возникающие из-за толстых интерфейсов. Приведите сценарий, где изменение одного метода ломает много несвязанных компонентов. 
        Сценарий: в интерфейс IUser добавили метод UpdateSocialMedia(). Теперь все сервисы (отчеты, логин, биллинг), зависящие от IUser, должны быть перекомпилированы, даже если им социальные сети не нужны.

    Как ISP влияет на тестируемость? 
        Упрощает создание моков. Вместо реализации 20 методов «толстого» интерфейса для теста одного метода, вы реализуете маленький интерфейс из 1-2 методов.

    Чем отличается «интерфейс как роль» от «интерфейс как набор методов класса»? Приведите пример неправильного и правильного подхода. 
        Роль описывает конкретную обязанность (например, IPrintable). Набор методов — это просто слепок функций класса (например, IPrinterMachine со всем подряд). Правильно проектировать интерфейсы под нужды клиентов (роли).

    Как понять, что интерфейс нужно разделять? Назовите 3–5 практических признаков нарушения ISP в проекте. 
        1. Клиенты реализуют методы-заглушки. 2. Клиенты используют лишь малую часть методов. 3. Изменение метода в интерфейсе заставляет обновлять несвязанные модули. 4. Сложно создавать тестовые дублеры.

    В исправленном решении (IPrinter, IScanner, IFax) почему SimplePrinter становится проще и надёжнее? Какие классы больше не обязаны меняться при расширении системы? 
        Он реализует только IPrinter. Классы, работающие со сканером или факсом, больше не связаны с SimplePrinter, и их изменения не затронут его.

    Как изменение IFax (например, добавление параметра или нового метода) влияет на клиентов, работающих только с IPrinter? Почему это считается выигрышем архитектуры? 
        Никак не влияет. Клиенты IPrinter даже не «увидят» изменений в коде. Это выигрыш, так как изолирует части системы друг от друга.

    Предложите альтернативный дизайн устройства печати/сканирования без множественного наследования интерфейсов. Когда такой подход может быть предпочтительнее? 
        Использовать композицию: класс MFD содержит внутри объекты Printer, Scanner и Fax. Это предпочтительнее, когда части устройства имеют сложную логику и разный жизненный цикл.

    В каких случаях «слишком мелкие интерфейсы» могут стать проблемой? Опишите антипример чрезмерного применения ISP. 
        Это ведет к раздроблению и потере целостности (interface soup). Антипример: интерфейс на каждый отдельный метод (IPrinterWithPageSize, IPrinterWithColor). Клиентский код станет перегружен приведениями типов.

    Как вы находите баланс между «толстым» интерфейсом и «зоопарком» из десятков микр-интерфейсов? Какие критерии вы используете? 
        Баланс — в выделении логических ролей. Критерий: если группа методов всегда используется клиентами совместно, их можно оставить в одном интерфейсе.

    Если исходный интерфейс принадлежит сторонней библиотеке и изменить его нельзя, как применить ISP через адаптер? Опишите структуру решения и границы ответственности. 
        Создать свои маленькие интерфейсы и написать класс-адаптер, который реализует их, делегируя вызовы «толстому» интерфейсу библиотеки. Клиенты будут зависеть от ваших маленьких интерфейсов.

    Как ISP связан с принципом единственной ответственности (SRP)? Можно ли сказать, что «толстый интерфейс» часто является симптомом нарушения SRP? Обоснуйте. 
        Да. Если интерфейс требует реализации множества разнородных методов, значит, объект, реализующий его, берет на себя слишком много ответственностей. ISP — это SRP для интерфейсов.

    Как ISP связан с принципом инверсии зависимостей (DIP)? Почему DIP без ISP иногда приводит к «абстракциям-монстрам»? 
        DIP говорит зависеть от абстракций. Если абстракция (интерфейс) огромная, то DIP просто заставляет зависеть от «огромного монстра», сохраняя все проблемы сильной связности.

    Может ли интерфейс быть «толстым» и при этом не нарушать ISP? Приведите пример, когда широкий интерфейс оправдан и не создаёт лишних зависимостей. 
        Да, если все методы интерфейса являются частью одной неделимой услуги, и все его клиенты всегда используют все эти методы (например, методы Move, Rotate, Scale для 3D-манипулятора).

    Представьте, что вы проводите код-ревью и видите интерфейс из 20 методов. Какие вопросы вы зададите автору, чтобы проверить соблюдение ISP? 
        «Есть ли клиенты, которые используют только 2-3 метода из этого списка?» и «Что произойдет с остальными клиентами, если мы изменим сигнатуру этого метода?».

    Придумайте пример из реального домена (например, платежи, доставка, хранение файлов, игровые сущности), где разделение интерфейса по ролям существенно снижает связанность. Опишите до/после. 
        До: IUser (методы: GetLogin, GetBalance, Ban, SendEmail). После: разделение на IAuthenticatable, IBalanceHolder, IModeratable. Биллингу больше не нужно знать, как банить пользователя, он зависит только от IBalanceHolder.