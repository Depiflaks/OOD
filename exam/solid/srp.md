Принцип единственной ответственности (SRP)

Объясните принцип SRP своими словами. Что именно означает «одна причина для изменений» и чем она отличается от «класс делает одну задачу»? 
        SRP гласит, что класс должен отвечать за одну область функциональности, определяемую конкретным бизнес-актором. «Одна задача» — слишком узкое понятие (метод делает задачу), а «одна причина для изменений» означает, что только один источник требований (например, бухгалтерия или отдел маркетинга) может инициировать правки в этом классе.

Что такое «актор» (источник требований) в контексте SRP? Приведите 2–3 примера акторов в реальном проекте. 
        Актор — это группа пользователей или заинтересованных лиц, которым нужна данная функциональность. Примеры: 1. Бухгалтер (требует формат отчета). 2. Администратор БД (требует схему хранения). 3. Пользователь интерфейса (требует логику отображения).

Почему класс, который «умеет всё понемногу» (чтение файла, валидация, преобразование, логирование), становится хрупким? Опишите типичный сценарий поломки. 
        Хрупкость возникает из-за неявных зависимостей. Сценарий: вы меняете библиотеку логирования, что случайно ломает логику валидации или парсинга из-за общих полей или побочных эффектов. В итоге изменение одного аспекта требует перетестирования всех остальных.

Примените «тест одного предложения» к классу Bitmap, который хранит пиксели, рисует линии и сохраняет файл. Как вы сформулируете ответственность до и после рефакторинга? 
        До: «Класс хранит данные изображения, предоставляет инструменты рисования и управляет сохранением в файловую систему». После: «Класс Bitmap является контейнером для пиксельных данных» (рисование и сохранение выносятся в Renderer и Encoder).

В примере с Bitmap: какие две ответственности были вынесены из класса, и почему именно они являются отдельными причинами для изменений? 
        Вынесены алгоритмы рисования (меняются при изменении графического движка) и сериализация/сохранение (меняются при добавлении новых форматов файлов вроде PNG/JPG). Это разные причины, так как требования к рисованию и требования к форматам файлов исходят из разных технических задач.

Чем отличается «вынести методы в отдельный класс» от «сделать отдельный модуль/компонент»? В каких случаях SRP нужно применять на уровне модулей, а не классов? 
        Вынос в класс — это декомпозиция внутри одного кода. Вынос в модуль — это физическое разделение на уровне библиотек/сервисов. SRP на уровне модулей нужен, когда части системы имеют разные циклы релиза, разные требования к масштабированию или безопасности (например, вынос обработки платежей в отдельный сервис).

После применения SRP код стал более многословным. Почему это не всегда плохо? В каких случаях многословность превращается в реальную проблему? 
        Многословность оправдана, если она снижает связность и облегчает поддержку. Проблемой она становится, когда декомпозиция чрезмерна («атомарные классы»), что заставляет разработчика прыгать по десяткам файлов ради понимания простейшей операции.

Объясните проблему discoverability после рефакторинга Bitmap. Какие практические способы вы бы использовали, чтобы её снизить, не нарушая SRP? 
        Discoverability — сложность поиска нужного метода (раньше все было в Bitmap, теперь разбросано). Решения: использование паттерна Facade для объединения API, использование расширений (Extension methods) или создание реестра сервисов.

Какие признаки в коде подсказывают, что SRP нарушен, даже если класс «не выглядит большим»? Приведите несколько сигналов. 
        1. В методах много разных аргументов, не связанных друг с другом. 2. Наличие полей, которые используются только в одной группе методов. 3. Изменение одной части класса требует импорта библиотек, не нужных другой части.

Представьте класс UserService, который: валидирует пользователя, сохраняет в БД и отправляет email. Как вы выделите ответственности и какие классы/интерфейсы появятся? 
        Появятся: UserValidator (бизнес-правила), UserRepository (работа с БД) и EmailService или NotificationDispatcher (внешние коммуникации). UserService станет координатором.

Как SRP влияет на тестирование? Приведите пример: какие тесты становятся проще после разделения ответственностей? 
        Тесты становятся модульными и сфокусированными. Пример: чтобы протестировать UserValidator, вам больше не нужно настраивать мок базы данных или почтового сервера, вы тестируете только чистую логику правил.

В каких случаях нарушение SRP может быть оправдано? Приведите пример из практики, где «смешение ответственностей» — разумный компромисс. 
        В небольших скриптах, прототипах или в паттерне Active Record (где объект данных сам умеет сохраняться в БД). Это оправдано в CRUD-приложениях, где разделение только усложнит код без реальной выгоды в поддержке.

Что опаснее: нарушить SRP в доменной логике или в инфраструктурном коде (например, сериализация/логирование)? Обоснуйте. 
        Опаснее в доменной логике. Инфраструктура меняется редко и технически предсказуема. Доменная логика постоянно эволюционирует под давлением бизнеса; если она запутана с инфраструктурой, каждое бизнес-изменение будет рискованным и дорогим.

Почему после применения SRP часто «растёт количество классов»? Как отличить нормальную декомпозицию от архитектурного «размножения сущностей»? 
        Количество классов растет, так как каждая ответственность теперь имеет «дом». Декомпозиция нормальна, если каждый новый класс имеет четкого актора и переиспользуем. «Размножение» — это когда классы создаются механически (например, интерфейс на каждый класс без необходимости).

Опишите, как SRP помогает расширяемости на примере: добавление нового примитива рисования (например, окружности) и добавление нового формата сохранения. 
        При SRP для добавления окружности вы создаете новый класс в модуле рисования, не трогая код хранения. Для нового формата (например, WebP) вы создаете новый Encoder, не влияя на алгоритмы рисования. Риск сломать существующее минимален.

В примере PngImageEncoder: почему сохранение вынесено в отдельный класс, а не добавлено в Bitmap через метод SavePng()? Какие изменения требований к форматированию чисел (группировка разрядов, валюта, разделители, скобки для отрицательных) должны приводить к добавлению нового класса, а какие — к изменению существующего? Обоснуйте. 
        Вынесено, чтобы Bitmap не зависел от библиотек сжатия PNG (libpng и т.д.). Добавление SavePng() заставило бы перекомпилировать Bitmap при каждом обновлении формата. Новые форматы — новые классы; изменение параметров существующего формата (например, степень сжатия) — изменение существующего класса.

Предложите альтернативное решение, которое соблюдает SRP, но делает API удобнее: как можно упростить сохранение в один вызов? 
        Использовать Extension Methods (в C#/Kotlin) или свободные функции (в C++). Это позволит писать image.Save(encoder), где Save — лишь синтаксический сахар, вызывающий внешний класс, сохраняя чистоту самого Bitmap.

Чем SRP отличается от «God Object» как антипаттерна? Может ли класс не быть God Object, но при этом нарушать SRP? Приведите пример. 
        God Object — это экстремальный случай нарушения SRP (класс делает ВСЁ). Класс может не быть огромным, но нарушать SRP. Пример: класс Money, который хранит сумму и одновременно содержит логику отрисовки этой суммы в HTML. Он маленький, но имеет две ответственности.

Как SRP связан с другими принципами SOLID: OCP и DIP? Объясните, как SRP подготавливает почву для расширяемости без изменений. 
        Без SRP невозможно применить OCP: если в классе две задачи, вы не сможете расширить одну, не затронув другую. SRP выделяет «точки изменения», которые затем закрываются интерфейсами по DIP, позволяя менять реализации независимо.

Представьте, что вы делаете код-ревью. Какие вопросы вы зададите автору класса, чтобы проверить соблюдение SRP (без переписывания кода прямо сейчас)? 
        1. «Кто является инициатором изменений для этого метода и для того?» 2. «Можем ли мы протестировать расчеты без подключения базы данных?» 3. «Если завтра мы заменим консольный вывод на GUI, сколько методов в этом классе нам придется править?»