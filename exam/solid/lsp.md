Принцип подстановки Лисков (LSP)

    Сформулируйте LSP своими словами и объясните, чем «взаимозаменяемость» отличается от простого «наследования по смыслу». 
        Объекты в программе должны быть заменяемы на экземпляры их подтипов без изменения правильности работы программы. «Взаимозаменяемость» требует сохранения поведения и контрактов, тогда как «наследование по смыслу» (is-a) часто учитывает только внешнюю схожесть, игнорируя логические ограничения.

    Почему нарушения LSP особенно опасны в статически типизированных языках? Опишите типичный сценарий «всё компилируется, но работает неправильно». 
        Компилятор проверяет только сигнатуры методов, но не их семантику. Сценарий: метод принимает Shape, вызывает SetWidth(), ожидая изменения только ширины, но переданный Square меняет и высоту, ломая логику расчетов в рантайме.

    Что такое контракт базового типа? Назовите его элементы (предусловия, постусловия, инварианты) и объясните их роль в LSP. 
        Это набор правил и гарантий метода. Предусловия — требования к входным данным; постусловия — гарантии результата; инварианты — условия, которые всегда истинны для объекта. LSP требует, чтобы подкласс соблюдал эти правила, не ломая ожидания клиента.

    Приведите пример усиления предусловия в подклассе и объясните, почему это нарушает LSP. 
        Базовый метод принимает любое целое число, а подкласс — только положительные. Это нарушение, так как клиент, рассчитывающий на базовый контракт, может передать отрицательное число и получить ошибку от подкласса.

    Приведите пример ослабления постусловия в подклассе и объясните, как это ломает ожидания клиента базового типа. 
        Базовый метод гарантирует возврат значения в диапазоне [1-100], а подкласс возвращает любое число. Клиент, не ожидающий значений вне диапазона, может некорректно обработать результат.

    Что означает «подкласс может ослаблять предусловия»? Приведите практический пример, где это полезно и корректно. 
        Это значит, что подкласс становится «менее требовательным» к входным данным. Пример: базовый метод требует только формат XML, а подкласс принимает и XML, и JSON. Это безопасно для старого клиента.

    Что означает «подкласс может усиливать постусловия»? Приведите практический пример, где подкласс даёт более сильные гарантии, чем базовый. 
        Подкласс дает более строгий или конкретный результат. Пример: базовый метод обещает вернуть Collection, а подкласс гарантирует всегда возвращать отсортированный List.

    Что такое инвариант базового класса? Приведите 2 примера инвариантов и покажите, как их нарушение в подклассе приводит к ошибкам. 
        Это условие, сохраняющееся в течение всей жизни объекта. Примеры: 1. «Баланс счета не может быть отрицательным». 2. «Ширина прямоугольника независима от высоты». Нарушение в подклассе (например, Square) ломает логику внешних алгоритмов, полагающихся на эти правила.

    Объясните, почему пример Rectangle/Square нарушает LSP именно на уровне поведения, а не на уровне математики. 
        Математически квадрат — это прямоугольник. Но в программировании Rectangle обладает поведением, позволяющим менять стороны независимо. Square не может обеспечить это поведение, не нарушая свою целостность, что делает их несовместимыми по контракту.

    Составьте пример клиентского кода (функции), который корректно работает с Rectangle, но ломается при подстановке Square. Объясните, какое ожидание нарушено. 
        void Scale(Rectangle& r) { r.SetWidth(10); r.SetHeight(5); assert(r.GetWidth() * r.SetHeight() == 50); }. Для квадрата утверждение будет ложным, так как SetHeight(5) изменит ширину на 5. Нарушено ожидание независимости сторон.

    Почему «кидать исключение в неподдерживаемом методе» (например, throw вместо реализации) часто является нарушением LSP? Когда это может быть допустимо? 
        Клиент ожидает, что если метод есть в интерфейсе, он выполняет работу. Исключение NotImplemented нарушает постусловие (результат не достигнут). Допустимо только если исключение является частью явного контракта базового типа для определенных состояний.

    Сравните способы решения проблемы Rectangle/Square: «разные классы через общий интерфейс» vs «immutable объекты». В чём различие по контрактам и по последствиям для API? 
        «Общий интерфейс» (IShape) разделяет их по поведению (убирает SetSize). «Immutable» объекты решают проблему тем, что стороны нельзя изменить после создания — контракт Rectangle больше не гарантирует возможность мутации, что делает Square безопасным подтипом.

    В чём идея решения «Square как фабрика Rectangle», и какие плюсы/минусы у такого подхода с точки зрения модели предметной области? 
        Вместо наследования Square просто возвращает новый объект Rectangle с равными сторонами. Плюс: чистота иерархии. Минус: мы теряем тип «Квадрат» как самостоятельную сущность в логике программы.

    Объясните решение «общий абстрактный тип без сеттеров размеров». Почему удаление операций изменения из базового интерфейса может восстановить LSP? 
        Если в базе нет методов SetWidth/SetHeight, то нет и контракта о независимом изменении сторон. Подклассы могут реализовать свои специфичные способы изменения, не нарушая общих ожиданий клиента базового типа.

    Приведите пример, где отказ от наследования в пользу композиции помогает соблюсти LSP. Опишите, какие зависимости и контракты меняются. 
        Вместо Worker : Person использовать Worker, который имеет (композиция) Person. Это убирает жесткий контракт «является» и позволяет Worker иметь свою специфичную логику, не обязанную соответствовать всем ожиданиям от Person.

    Как отличить «корректное расширение поведения подкласса» от «изменения смысла базового типа»? Какие вопросы вы зададите при ревью? 
        Корректное расширение добавляет новые возможности, не ломая старые. Вопросы: «Ожидает ли клиент базового класса, что этот метод может вернуть ошибку/исключение?» и «Сохраняются ли все математические и логические свойства базы в наследнике?».

    Может ли подкласс возвращать более конкретный тип (covariant return) и при этом соблюдать LSP? В каких условиях это безопасно? 
        Да, это пример усиления постусловия. Безопасно, если клиент базового типа все еще может работать с результатом через интерфейс базового возвращаемого типа.

    Как вы будете тестировать соблюдение LSP? Опишите подход к тестам: какие свойства или сценарии должны выполняться для всех реализаций базового типа. 
        Создание набора тестов (Contract Tests) для базового интерфейса. Эти тесты должны успешно проходить для всех подклассов. Если подкласс валит тест, написанный для базового типа — LSP нарушен.

    Как LSP связано с проектированием интерфейсов в целом (и с ISP/OCP)? Объясните, как неправильная абстракция приводит к цепочке нарушений принципов. 
        Неверная абстракция заставляет подклассы реализовывать ненужные методы (нарушение ISP), что ведет к заглушкам с исключениями (нарушение LSP), что в итоге делает систему закрытой для расширения (нарушение OCP) из-за хрупкости.

    Приведите пример из реального домена (например, платёжные методы, аккаунты, кэш/репозиторий, файловые потоки), где естественное на первый взгляд наследование приводит к нарушению LSP. Предложите корректную модель. 
        Наследование ReadOnlyFile : File. Если в File есть метод Write(), то ReadOnlyFile вынужден бросать исключение. Корректно: разделить на IReadable и IWritable, и наследоваться только от нужного интерфейса.