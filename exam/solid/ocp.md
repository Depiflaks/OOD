Принцип открытости-закрытости (OCP)

Сформулируйте принцип OCP своими словами. Что означает «открыт для расширения» и «закрыт для изменения» в контексте реального проекта? 
        Система должна позволять добавлять новую функциональность (расширение), не меняя при этом уже написанный и протестированный исходный код (закрытость). В проекте это реализуется через добавление новых классов вместо правки существующих switch/if.

Почему «закрыт для изменения» не означает «код никогда нельзя менять»? В каких случаях изменение существующего кода является нормальным и ожидаемым? 
        «Закрытость» касается стабильных контрактов и логики. Исправление багов, рефакторинг для улучшения читаемости или изменение фундаментальных требований (когда старая логика более не актуальна) — это нормальные случаи изменения кода.

Приведите пример требования, которое в плохой архитектуре приводит к большим правкам, а в хорошей — к добавлению нового кода без изменения старого. Объясните разницу. 
        Требование: «Добавить выгрузку отчета в Excel к уже существующей выгрузке в PDF». В плохой архитектуре вы правите ReportGenerator, добавляя новый if. В хорошей — создаете ExcelFormatter, реализующий IFormatter, и регистрируете его в системе.

Какие признаки в коде говорят о нарушении OCP? Перечислите 3–5 сигналов. 
        1. Массивные блоки if-else или switch по типам объектов. 2. Частое использование dynamic_cast или instanceof. 3. Необходимость править 5-10 разных файлов при добавлении одной простой фичи. 4. Класс имеет жесткие зависимости от конкретных реализаций (new в коде).

В примере с Logger, почему зависимость от std::ofstream является проблемой с точки зрения OCP? Какой «вариант изменения требований» ломает этот дизайн? 
        Зависимость от std::ofstream привязывает логгер к файловой системе. Требование отправлять логи в сеть (UDP) или в системный журнал (syslog) «ломает» дизайн, так как требует переписывания внутренностей Logger.

В примере с ILogSink: какая часть поведения была выделена как изменяемая? Почему именно её нужно было «вынести наружу»? 
        Был выделен способ вывода данных (назначение лога). Его нужно вынести, так как логика формирования сообщения (таймстампы, уровни) стабильна, а каналы вывода (файл, консоль, сеть) постоянно меняются или добавляются.

Почему решение через ILogSink делает систему расширяемой? Опишите, как добавить SyslogSink или NetworkSink, не меняя Logger. 
        Logger теперь работает с абстракцией. Чтобы добавить SyslogSink, вы просто создаете новый класс, реализующий ILogSink, и передаете его экземпляр в Logger. Код Logger при этом остается нетронутым.

В чём архитектурная цена решения через интерфейсы (ILogSink, IReportFormatter)? Какие риски появляются при росте числа абстракций? 
        Цена — усложнение навигации по коду и косвенность (indirection). Риски: «взрыв» количества интерфейсов, сложность отладки (непонятно, какая именно реализация вызвана) и потенциальное падение производительности из-за виртуальных вызовов.

Объясните разницу между расширением поведения через наследование и через композицию в контексте OCP. Когда что предпочтительнее? 
        Наследование расширяет класс «вглубь», создавая жесткую связь. Композиция (Strategy) вкладывает поведение в объект. Композиция почти всегда предпочтительнее, так как позволяет менять поведение в рантайме и избегает проблем глубоких иерархий.

В каких случаях параметризация поведением через лямбды или std::function может быть лучшим способом соблюсти OCP, чем создание иерархии классов? 
        Когда поведение простое (одна функция) и не требует хранения состояния. Это избавляет от создания лишних интерфейсов и файлов-классов, делая код лаконичным и быстрым.

Как в C++ можно реализовать OCP на этапе компиляции? Опишите идею «policy-based design» или шаблонного параметра поведения. 
        Это достигается через шаблоны. Класс принимает Policy как параметр шаблона. На этапе компиляции подставляется конкретный тип. Это дает расширяемость без накладных расходов виртуальных функций (статический полиморфизм).

Приведите пример, где OCP реализуется через шаблонный параметр. Какие плюсы и минусы такого подхода? 
        Пример: std::sort принимает компаратор. Плюсы: максимальная производительность, проверка типов в compile-time. Минусы: код шаблонов сложнее читать, ошибки компиляции становятся монструозными, увеличивается время сборки.

В примере с рендерингом отчёта: почему попытка добавить поддержку разных форматов через if/else внутри ReportRenderer является нарушением OCP? 
        Потому что каждый новый формат (HTML, XML, Markdown) вынуждает нас открывать файл ReportRenderer.cpp и менять его. Это повышает риск сломать старые форматы при добавлении новых.

Какие изменения требований к форматированию чисел (группировка разрядов, валюта, разделители, скобки для отрицательных) должны приводить к добавлению нового класса, а какие — к изменению существующего? Обоснуйте. 
        Новая локаль или принципиально другой стандарт (например, бухгалтерский учет) — новый класс. Исправление ошибки в существующем правиле или уточнение константы (например, символ валюты) — изменение существующего класса.

Объясните, как паттерн Strategy помогает соблюдать OCP на примере IReportFormatter или ILogSink. 
        Паттерн Strategy выносит алгоритм (форматирование/вывод) в отдельный интерфейс. Контекст использует интерфейс, позволяя подставлять любые стратегии без изменения своего кода. Это классическая реализация OCP.

Как паттерн Decorator может быть применён для расширения логгера (например, добавление timestamp, фильтрация по уровню, буферизация) без изменения исходного класса? 
        Декоратор оборачивает базовый логгер. TimestampDecorator добавляет время и вызывает baseLogger->Log(). Вы можете комбинировать их (матрёшка), добавляя функционал динамически, не меняя ни строчки в базовом Logger.

Как паттерн Template Method может помочь соблюсти OCP? Приведите пример алгоритма, где меняются только отдельные шаги. 
        Базовый класс задает скелет алгоритма, оставляя «дырки» (виртуальные методы) для шагов. Пример: DataMiner открывает файл, парсит его (шаг), анализирует (шаг) и закрывает. Наследники переопределяют только парсинг для CSV или JSON.

Как паттерны Factory Method и Abstract Factory связаны с OCP? Почему создание объектов часто становится «точкой расширения»? 
        Они закрывают код клиента от знания о конкретных классах. Чтобы добавить новый продукт, вы расширяете фабрику или создаете новую, а клиентский код, работающий с интерфейсом продукта, остается неизменным.

Что такое «преждевременная абстракция» в контексте OCP? Приведите пример, когда попытка «сделать расширяемо заранее» приводит к ухудшению дизайна. 
        Это создание интерфейсов там, где вероятность изменения требований стремится к нулю. Пример: создание IUserFirstName на случай, если завтра имя станет не строкой, а списком объектов. Это создает «мусорный» код и запутывает проект.

Представьте, что вы проводите код-ревью. Какие вопросы вы зададите автору, чтобы понять: реализован ли OCP осознанно, или код стал “расширяемым ради расширяемости”? 
        1. «Насколько вероятно появление третьего/четвертого варианта реализации этого поведения?» 2. «Можем ли мы добавить новую логику, не создавая новый интерфейс, а просто параметризовав старый?» 3. «Оправдана ли здесь гибкость ценой потери производительности/читаемости?»